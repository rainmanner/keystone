(self.webpackChunkreact_boilerplate = self.webpackChunkreact_boilerplate || []).push([
    [8095], {
        99231: (e, t, i) => {
            (e.exports = i(23645)(!1)).push([e.id, "/**\n * Swiper 8.4.5\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2022 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: November 21, 2022\n */\n\n@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;box-sizing:content-box}.swiper-android .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-pointer-events{touch-action:pan-y}.swiper-pointer-events.swiper-vertical{touch-action:pan-x}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d,.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide,.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top,.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-horizontal.swiper-css-mode>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-vertical.swiper-css-mode>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center}.swiper-virtual .swiper-slide{-webkit-backface-visibility:hidden;transform:translateZ(0)}.swiper-virtual.swiper-css-mode .swiper-wrapper::after{content:'';position:absolute;left:0;top:0;pointer-events:none}.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after{height:1px;width:var(--swiper-virtual-size)}.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after{width:1px;height:var(--swiper-virtual-size)}:root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;font-variant:initial;line-height:1}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:10px;right:auto}.swiper-button-prev:after,.swiper-rtl .swiper-button-next:after{content:'prev'}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:10px;left:auto}.swiper-button-next:after,.swiper-rtl .swiper-button-prev:after{content:'next'}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:50%;background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:10px;top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:4px;height:100%;left:0;top:0}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0,0,0,.1)}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0,0,0,.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;object-fit:contain}.swiper-slide-zoomed{cursor:move}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.swiper .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}.swiper-grid>.swiper-wrapper{flex-wrap:wrap}.swiper-grid-column>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-fade.swiper-free-mode .swiper-slide{transition-timing-function:ease-out}.swiper-fade .swiper-slide{pointer-events:none;transition-property:opacity}.swiper-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-fade .swiper-slide-active,.swiper-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube{overflow:visible}.swiper-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-cube.swiper-rtl .swiper-slide{transform-origin:100% 0}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-next,.swiper-cube .swiper-slide-next+.swiper-slide,.swiper-cube .swiper-slide-prev{pointer-events:auto;visibility:visible}.swiper-cube .swiper-slide-shadow-bottom,.swiper-cube .swiper-slide-shadow-left,.swiper-cube .swiper-slide-shadow-right,.swiper-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;filter:blur(50px)}.swiper-flip{overflow:visible}.swiper-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-flip .swiper-slide-active,.swiper-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-flip .swiper-slide-shadow-bottom,.swiper-flip .swiper-slide-shadow-left,.swiper-flip .swiper-slide-shadow-right,.swiper-flip .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-creative .swiper-slide{-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper-cards{overflow:visible}.swiper-cards .swiper-slide{transform-origin:center bottom;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden}", ""])
        },
        71150: (e, t, i) => {
            var s = i(99231);
            "string" === typeof s && (s = [
                [e.id, s, ""]
            ]);
            i(76723)(s, {
                hmr: !0,
                transform: void 0,
                insertInto: void 0
            }), s.locals && (e.exports = s.locals)
        },
        50221: (e, t, i) => {
            "use strict";
            i.d(t, {
                tq: () => y,
                o5: () => C
            });
            var s = i(67294),
                a = i(89995);

            function r(e) {
                return "object" === typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
            }

            function n(e, t) {
                const i = ["__proto__", "constructor", "prototype"];
                Object.keys(t).filter((e => i.indexOf(e) < 0)).forEach((i => {
                    "undefined" === typeof e[i] ? e[i] = t[i] : r(t[i]) && r(e[i]) && Object.keys(t[i]).length > 0 ? t[i].__swiper__ ? e[i] = t[i] : n(e[i], t[i]) : e[i] = t[i]
                }))
            }

            function l(e = {}) {
                return e.navigation && "undefined" === typeof e.navigation.nextEl && "undefined" === typeof e.navigation.prevEl
            }

            function o(e = {}) {
                return e.pagination && "undefined" === typeof e.pagination.el
            }

            function p(e = {}) {
                return e.scrollbar && "undefined" === typeof e.scrollbar.el
            }

            function d(e = "") {
                const t = e.split(" ").map((e => e.trim())).filter((e => !!e)),
                    i = [];
                return t.forEach((e => {
                    i.indexOf(e) < 0 && i.push(e)
                })), i.join(" ")
            }
            const c = ["modules", "init", "_direction", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_preloadImages", "updateOnImagesReady", "_loop", "_loopAdditionalSlides", "_loopedSlides", "_loopedSlidesLimit", "_loopFillGroupWithBlank", "loopPreventsSlide", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideBlankClass", "slideActiveClass", "slideDuplicateActiveClass", "slideVisibleClass", "slideDuplicateClass", "slideNextClass", "slideDuplicateNextClass", "slidePrevClass", "slideDuplicatePrevClass", "wrapperClass", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "lazy", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom"],
                u = (e, t) => {
                    let i = t.slidesPerView;
                    if (t.breakpoints) {
                        const e = a.ZP.prototype.getBreakpoint(t.breakpoints),
                            s = e in t.breakpoints ? t.breakpoints[e] : void 0;
                        s && s.slidesPerView && (i = s.slidesPerView)
                    }
                    let s = Math.ceil(parseFloat(t.loopedSlides || i, 10));
                    return s += t.loopAdditionalSlides, s > e.length && t.loopedSlidesLimit && (s = e.length), s
                };

            function f(e) {
                return e.type && e.type.displayName && e.type.displayName.includes("SwiperSlide")
            }

            function g(e) {
                const t = [];
                return s.Children.toArray(e).forEach((e => {
                    f(e) ? t.push(e) : e.props && e.props.children && g(e.props.children).forEach((e => t.push(e)))
                })), t
            }

            function h(e) {
                const t = [],
                    i = {
                        "container-start": [],
                        "container-end": [],
                        "wrapper-start": [],
                        "wrapper-end": []
                    };
                return s.Children.toArray(e).forEach((e => {
                    if (f(e)) t.push(e);
                    else if (e.props && e.props.slot && i[e.props.slot]) i[e.props.slot].push(e);
                    else if (e.props && e.props.children) {
                        const s = g(e.props.children);
                        s.length > 0 ? s.forEach((e => t.push(e))) : i["container-end"].push(e)
                    } else i["container-end"].push(e)
                })), {
                    slides: t,
                    slots: i
                }
            }

            function w(e, t) {
                return "undefined" === typeof window ? (0, s.useEffect)(e, t) : (0, s.useLayoutEffect)(e, t)
            }
            const m = (0, s.createContext)(null),
                v = (0, s.createContext)(null);

            function b() {
                return b = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var i = arguments[t];
                        for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (e[s] = i[s])
                    }
                    return e
                }, b.apply(this, arguments)
            }
            const y = (0, s.forwardRef)((function(e, t) {
                let {
                    className: i,
                    tag: f = "div",
                    wrapperTag: g = "div",
                    children: m,
                    onSwiper: y,
                    ...A
                } = void 0 === e ? {} : e, C = !1;
                const [x, S] = (0, s.useState)("swiper"), [E, T] = (0, s.useState)(null), [k, M] = (0, s.useState)(!1), P = (0, s.useRef)(!1), $ = (0, s.useRef)(null), z = (0, s.useRef)(null), O = (0, s.useRef)(null), I = (0, s.useRef)(null), B = (0, s.useRef)(null), L = (0, s.useRef)(null), G = (0, s.useRef)(null), D = (0, s.useRef)(null), {
                    params: _,
                    passedParams: j,
                    rest: N,
                    events: Y
                } = function(e = {}, t = !0) {
                    const i = {
                            on: {}
                        },
                        s = {},
                        l = {};
                    n(i, a.ZP.defaults), n(i, a.ZP.extendedDefaults), i._emitClasses = !0, i.init = !1;
                    const o = {},
                        p = c.map((e => e.replace(/_/, ""))),
                        d = Object.assign({}, e);
                    return Object.keys(d).forEach((a => {
                        "undefined" !== typeof e[a] && (p.indexOf(a) >= 0 ? r(e[a]) ? (i[a] = {}, l[a] = {}, n(i[a], e[a]), n(l[a], e[a])) : (i[a] = e[a], l[a] = e[a]) : 0 === a.search(/on[A-Z]/) && "function" === typeof e[a] ? t ? s[`${a[2].toLowerCase()}${a.substr(3)}`] = e[a] : i.on[`${a[2].toLowerCase()}${a.substr(3)}`] = e[a] : o[a] = e[a])
                    })), ["navigation", "pagination", "scrollbar"].forEach((e => {
                        !0 === i[e] && (i[e] = {}), !1 === i[e] && delete i[e]
                    })), {
                        params: i,
                        passedParams: l,
                        rest: o,
                        events: s
                    }
                }(A), {
                    slides: F,
                    slots: R
                } = h(m), H = () => {
                    M(!k)
                };
                Object.assign(_.on, {
                    _containerClasses(e, t) {
                        S(t)
                    }
                });
                const V = () => {
                    if (Object.assign(_.on, Y), C = !0, z.current = new a.ZP(_), z.current.loopCreate = () => {}, z.current.loopDestroy = () => {}, _.loop && (z.current.loopedSlides = u(F, _)), z.current.virtual && z.current.params.virtual.enabled) {
                        z.current.virtual.slides = F;
                        const e = {
                            cache: !1,
                            slides: F,
                            renderExternal: T,
                            renderExternalUpdate: !1
                        };
                        n(z.current.params.virtual, e), n(z.current.originalParams.virtual, e)
                    }
                };
                return $.current || V(), z.current && z.current.on("_beforeBreakpoint", H), (0, s.useEffect)((() => () => {
                    z.current && z.current.off("_beforeBreakpoint", H)
                })), (0, s.useEffect)((() => {
                    !P.current && z.current && (z.current.emitSlidesClasses(), P.current = !0)
                })), w((() => {
                    if (t && (t.current = $.current), $.current) return z.current.destroyed && V(),
                        function({
                            el: e,
                            nextEl: t,
                            prevEl: i,
                            paginationEl: s,
                            scrollbarEl: a,
                            swiper: r
                        }, n) {
                            l(n) && t && i && (r.params.navigation.nextEl = t, r.originalParams.navigation.nextEl = t, r.params.navigation.prevEl = i, r.originalParams.navigation.prevEl = i), o(n) && s && (r.params.pagination.el = s, r.originalParams.pagination.el = s), p(n) && a && (r.params.scrollbar.el = a, r.originalParams.scrollbar.el = a), r.init(e)
                        }({
                            el: $.current,
                            nextEl: B.current,
                            prevEl: L.current,
                            paginationEl: G.current,
                            scrollbarEl: D.current,
                            swiper: z.current
                        }, _), y && y(z.current), () => {
                            z.current && !z.current.destroyed && z.current.destroy(!0, !1)
                        }
                }), []), w((() => {
                    !C && Y && z.current && Object.keys(Y).forEach((e => {
                        z.current.on(e, Y[e])
                    }));
                    const e = function(e, t, i, s, a) {
                        const n = [];
                        if (!t) return n;
                        const l = e => {
                            n.indexOf(e) < 0 && n.push(e)
                        };
                        if (i && s) {
                            const e = s.map(a),
                                t = i.map(a);
                            e.join("") !== t.join("") && l("children"), s.length !== i.length && l("children")
                        }
                        return c.filter((e => "_" === e[0])).map((e => e.replace(/_/, ""))).forEach((i => {
                            if (i in e && i in t)
                                if (r(e[i]) && r(t[i])) {
                                    const s = Object.keys(e[i]),
                                        a = Object.keys(t[i]);
                                    s.length !== a.length ? l(i) : (s.forEach((s => {
                                        e[i][s] !== t[i][s] && l(i)
                                    })), a.forEach((s => {
                                        e[i][s] !== t[i][s] && l(i)
                                    })))
                                } else e[i] !== t[i] && l(i)
                        })), n
                    }(j, O.current, F, I.current, (e => e.key));
                    return O.current = j, I.current = F, e.length && z.current && !z.current.destroyed && function({
                        swiper: e,
                        slides: t,
                        passedParams: i,
                        changedParams: s,
                        nextEl: a,
                        prevEl: l,
                        scrollbarEl: o,
                        paginationEl: p
                    }) {
                        const d = s.filter((e => "children" !== e && "direction" !== e)),
                            {
                                params: c,
                                pagination: u,
                                navigation: f,
                                scrollbar: g,
                                virtual: h,
                                thumbs: w
                            } = e;
                        let m, v, b, y, A;
                        s.includes("thumbs") && i.thumbs && i.thumbs.swiper && c.thumbs && !c.thumbs.swiper && (m = !0), s.includes("controller") && i.controller && i.controller.control && c.controller && !c.controller.control && (v = !0), s.includes("pagination") && i.pagination && (i.pagination.el || p) && (c.pagination || !1 === c.pagination) && u && !u.el && (b = !0), s.includes("scrollbar") && i.scrollbar && (i.scrollbar.el || o) && (c.scrollbar || !1 === c.scrollbar) && g && !g.el && (y = !0), s.includes("navigation") && i.navigation && (i.navigation.prevEl || l) && (i.navigation.nextEl || a) && (c.navigation || !1 === c.navigation) && f && !f.prevEl && !f.nextEl && (A = !0), d.forEach((t => {
                            if (r(c[t]) && r(i[t])) n(c[t], i[t]);
                            else {
                                const a = i[t];
                                !0 !== a && !1 !== a || "navigation" !== t && "pagination" !== t && "scrollbar" !== t ? c[t] = i[t] : !1 === a && e[s = t] && (e[s].destroy(), "navigation" === s ? (c[s].prevEl = void 0, c[s].nextEl = void 0, e[s].prevEl = void 0, e[s].nextEl = void 0) : (c[s].el = void 0, e[s].el = void 0))
                            }
                            var s
                        })), d.includes("controller") && !v && e.controller && e.controller.control && c.controller && c.controller.control && (e.controller.control = c.controller.control), s.includes("children") && t && h && c.virtual.enabled ? (h.slides = t, h.update(!0)) : s.includes("children") && e.lazy && e.params.lazy.enabled && e.lazy.load(), m && w.init() && w.update(!0), v && (e.controller.control = c.controller.control), b && (p && (c.pagination.el = p), u.init(), u.render(), u.update()), y && (o && (c.scrollbar.el = o), g.init(), g.updateSize(), g.setTranslate()), A && (a && (c.navigation.nextEl = a), l && (c.navigation.prevEl = l), f.init(), f.update()), s.includes("allowSlideNext") && (e.allowSlideNext = i.allowSlideNext), s.includes("allowSlidePrev") && (e.allowSlidePrev = i.allowSlidePrev), s.includes("direction") && e.changeDirection(i.direction, !1), e.update()
                    }({
                        swiper: z.current,
                        slides: F,
                        passedParams: j,
                        changedParams: e,
                        nextEl: B.current,
                        prevEl: L.current,
                        scrollbarEl: D.current,
                        paginationEl: G.current
                    }), () => {
                        Y && z.current && Object.keys(Y).forEach((e => {
                            z.current.off(e, Y[e])
                        }))
                    }
                })), w((() => {
                    var e;
                    !(e = z.current) || e.destroyed || !e.params.virtual || e.params.virtual && !e.params.virtual.enabled || (e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.lazy && e.params.lazy.enabled && e.lazy.load(), e.parallax && e.params.parallax && e.params.parallax.enabled && e.parallax.setTranslate())
                }), [E]), s.createElement(f, b({
                    ref: $,
                    className: d(`${x}${i?` ${i}`:""}`)
                }, N), s.createElement(v.Provider, {
                    value: z.current
                }, R["container-start"], s.createElement(g, {
                    className: "swiper-wrapper"
                }, R["wrapper-start"], _.virtual ? function(e, t, i) {
                    if (!i) return null;
                    const a = e.isHorizontal() ? {
                        [e.rtlTranslate ? "right" : "left"]: `${i.offset}px`
                    } : {
                        top: `${i.offset}px`
                    };
                    return t.filter(((e, t) => t >= i.from && t <= i.to)).map((t => s.cloneElement(t, {
                        swiper: e,
                        style: a
                    })))
                }(z.current, F, E) : !_.loop || z.current && z.current.destroyed ? F.map((e => s.cloneElement(e, {
                    swiper: z.current
                }))) : function(e, t, i) {
                    const a = t.map(((t, i) => s.cloneElement(t, {
                        swiper: e,
                        "data-swiper-slide-index": i
                    })));

                    function r(e, t, a) {
                        return s.cloneElement(e, {
                            key: `${e.key}-duplicate-${t}-${a}`,
                            className: `${e.props.className||""} ${i.slideDuplicateClass}`
                        })
                    }
                    if (i.loopFillGroupWithBlank) {
                        const e = i.slidesPerGroup - a.length % i.slidesPerGroup;
                        if (e !== i.slidesPerGroup)
                            for (let t = 0; t < e; t += 1) {
                                const e = s.createElement("div", {
                                    className: `${i.slideClass} ${i.slideBlankClass}`
                                });
                                a.push(e)
                            }
                    }
                    "auto" !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = a.length);
                    const n = u(a, i),
                        l = [],
                        o = [];
                    for (let e = 0; e < n; e += 1) {
                        const t = e - Math.floor(e / a.length) * a.length;
                        o.push(r(a[t], e, "append")), l.unshift(r(a[a.length - t - 1], e, "prepend"))
                    }
                    return e && (e.loopedSlides = n), [...l, ...a, ...o]
                }(z.current, F, _), R["wrapper-end"]), l(_) && s.createElement(s.Fragment, null, s.createElement("div", {
                    ref: L,
                    className: "swiper-button-prev"
                }), s.createElement("div", {
                    ref: B,
                    className: "swiper-button-next"
                })), p(_) && s.createElement("div", {
                    ref: D,
                    className: "swiper-scrollbar"
                }), o(_) && s.createElement("div", {
                    ref: G,
                    className: "swiper-pagination"
                }), R["container-end"]))
            }));

            function A() {
                return A = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var i = arguments[t];
                        for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (e[s] = i[s])
                    }
                    return e
                }, A.apply(this, arguments)
            }
            y.displayName = "Swiper";
            const C = (0, s.forwardRef)((function(e, t) {
                let {
                    tag: i = "div",
                    children: a,
                    className: r = "",
                    swiper: n,
                    zoom: l,
                    virtualIndex: o,
                    ...p
                } = void 0 === e ? {} : e;
                const c = (0, s.useRef)(null),
                    [u, f] = (0, s.useState)("swiper-slide");

                function g(e, t, i) {
                    t === c.current && f(i)
                }
                w((() => {
                    if (t && (t.current = c.current), c.current && n) {
                        if (!n.destroyed) return n.on("_slideClass", g), () => {
                            n && n.off("_slideClass", g)
                        };
                        "swiper-slide" !== u && f("swiper-slide")
                    }
                })), w((() => {
                    n && c.current && !n.destroyed && f(n.getSlideClasses(c.current))
                }), [n]);
                const h = {
                        isActive: u.indexOf("swiper-slide-active") >= 0 || u.indexOf("swiper-slide-duplicate-active") >= 0,
                        isVisible: u.indexOf("swiper-slide-visible") >= 0,
                        isDuplicate: u.indexOf("swiper-slide-duplicate") >= 0,
                        isPrev: u.indexOf("swiper-slide-prev") >= 0 || u.indexOf("swiper-slide-duplicate-prev") >= 0,
                        isNext: u.indexOf("swiper-slide-next") >= 0 || u.indexOf("swiper-slide-duplicate-next") >= 0
                    },
                    v = () => "function" === typeof a ? a(h) : a;
                return s.createElement(i, A({
                    ref: c,
                    className: d(`${u}${r?` ${r}`:""}`),
                    "data-swiper-slide-index": o
                }, p), s.createElement(m.Provider, {
                    value: h
                }, l ? s.createElement("div", {
                    className: "swiper-zoom-container",
                    "data-swiper-zoom": "number" === typeof l ? l : void 0
                }, v()) : v()))
            }));
            C.displayName = "SwiperSlide"
        },
        89995: (e, t, i) => {
            "use strict";
            i.d(t, {
                pt: () => R,
                W_: () => N,
                tl: () => F,
                o3: () => H,
                ZP: () => _
            });
            var s = i(77628),
                a = i(14602);
            const r = {
                addClass: a.cn,
                removeClass: a.IV,
                hasClass: a.pv,
                toggleClass: a.Vj,
                attr: a.Lj,
                removeAttr: a.uV,
                transform: a.vs,
                transition: a.eR,
                on: a.on,
                off: a.S1,
                trigger: a.X$,
                transitionEnd: a.ld,
                outerWidth: a.iO,
                outerHeight: a.Pb,
                styles: a.W2,
                offset: a.cv,
                css: a.iv,
                each: a.S6,
                html: a.dy,
                text: a.fL,
                is: a.is,
                index: a.Kz,
                eq: a.eq,
                append: a.R3,
                prepend: a.Ce,
                next: a.lp,
                nextAll: a.eG,
                prev: a.mp,
                prevAll: a.pJ,
                parent: a.qm,
                parents: a.wV,
                closest: a.oq,
                find: a.sE,
                children: a.pI,
                filter: a.hX,
                remove: a.Od
            };
            Object.keys(r).forEach((e => {
                Object.defineProperty(a.$.fn, e, {
                    value: r[e],
                    writable: !0
                })
            }));
            const n = a.$;

            function l(e, t = 0) {
                return setTimeout(e, t)
            }

            function o() {
                return Date.now()
            }

            function p(e) {
                return "object" === typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
            }

            function d(...e) {
                const t = Object(e[0]),
                    i = ["__proto__", "constructor", "prototype"];
                for (let a = 1; a < e.length; a += 1) {
                    const r = e[a];
                    if (void 0 !== r && null !== r && (s = r, !("undefined" !== typeof window && "undefined" !== typeof window.HTMLElement ? s instanceof HTMLElement : s && (1 === s.nodeType || 11 === s.nodeType)))) {
                        const e = Object.keys(Object(r)).filter((e => i.indexOf(e) < 0));
                        for (let i = 0, s = e.length; i < s; i += 1) {
                            const s = e[i],
                                a = Object.getOwnPropertyDescriptor(r, s);
                            void 0 !== a && a.enumerable && (p(t[s]) && p(r[s]) ? r[s].__swiper__ ? t[s] = r[s] : d(t[s], r[s]) : !p(t[s]) && p(r[s]) ? (t[s] = {}, r[s].__swiper__ ? t[s] = r[s] : d(t[s], r[s])) : t[s] = r[s])
                        }
                    }
                }
                var s;
                return t
            }

            function c(e, t, i) {
                e.style.setProperty(t, i)
            }

            function u({
                swiper: e,
                targetPosition: t,
                side: i
            }) {
                const a = (0, s.Jj)(),
                    r = -e.translate;
                let n, l = null;
                const o = e.params.speed;
                e.wrapperEl.style.scrollSnapType = "none", a.cancelAnimationFrame(e.cssModeFrameID);
                const p = t > r ? "next" : "prev",
                    d = (e, t) => "next" === p && e >= t || "prev" === p && e <= t,
                    c = () => {
                        n = (new Date).getTime(), null === l && (l = n);
                        const s = Math.max(Math.min((n - l) / o, 1), 0),
                            p = .5 - Math.cos(s * Math.PI) / 2;
                        let u = r + p * (t - r);
                        if (d(u, t) && (u = t), e.wrapperEl.scrollTo({
                                [i]: u
                            }), d(u, t)) return e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout((() => {
                            e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({
                                [i]: u
                            })
                        })), void a.cancelAnimationFrame(e.cssModeFrameID);
                        e.cssModeFrameID = a.requestAnimationFrame(c)
                    };
                c()
            }
            let f, g, h;

            function w() {
                return f || (f = function() {
                    const e = (0, s.Jj)(),
                        t = (0, s.Me)();
                    return {
                        smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style,
                        touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch),
                        passiveListener: function() {
                            let t = !1;
                            try {
                                const i = Object.defineProperty({}, "passive", {
                                    get() {
                                        t = !0
                                    }
                                });
                                e.addEventListener("testPassiveListener", null, i)
                            } catch (e) {}
                            return t
                        }(),
                        gestures: "ongesturestart" in e
                    }
                }()), f
            }
            const m = {
                    on(e, t, i) {
                        const s = this;
                        if (!s.eventsListeners || s.destroyed) return s;
                        if ("function" !== typeof t) return s;
                        const a = i ? "unshift" : "push";
                        return e.split(" ").forEach((e => {
                            s.eventsListeners[e] || (s.eventsListeners[e] = []), s.eventsListeners[e][a](t)
                        })), s
                    },
                    once(e, t, i) {
                        const s = this;
                        if (!s.eventsListeners || s.destroyed) return s;
                        if ("function" !== typeof t) return s;

                        function a(...i) {
                            s.off(e, a), a.__emitterProxy && delete a.__emitterProxy, t.apply(s, i)
                        }
                        return a.__emitterProxy = t, s.on(e, a, i)
                    },
                    onAny(e, t) {
                        const i = this;
                        if (!i.eventsListeners || i.destroyed) return i;
                        if ("function" !== typeof e) return i;
                        const s = t ? "unshift" : "push";
                        return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[s](e), i
                    },
                    offAny(e) {
                        const t = this;
                        if (!t.eventsListeners || t.destroyed) return t;
                        if (!t.eventsAnyListeners) return t;
                        const i = t.eventsAnyListeners.indexOf(e);
                        return i >= 0 && t.eventsAnyListeners.splice(i, 1), t
                    },
                    off(e, t) {
                        const i = this;
                        return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach((e => {
                            "undefined" === typeof t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach(((s, a) => {
                                (s === t || s.__emitterProxy && s.__emitterProxy === t) && i.eventsListeners[e].splice(a, 1)
                            }))
                        })), i) : i
                    },
                    emit(...e) {
                        const t = this;
                        if (!t.eventsListeners || t.destroyed) return t;
                        if (!t.eventsListeners) return t;
                        let i, s, a;
                        return "string" === typeof e[0] || Array.isArray(e[0]) ? (i = e[0], s = e.slice(1, e.length), a = t) : (i = e[0].events, s = e[0].data, a = e[0].context || t), s.unshift(a), (Array.isArray(i) ? i : i.split(" ")).forEach((e => {
                            t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach((t => {
                                t.apply(a, [e, ...s])
                            })), t.eventsListeners && t.eventsListeners[e] && t.eventsListeners[e].forEach((e => {
                                e.apply(a, s)
                            }))
                        })), t
                    }
                },
                v = {
                    updateSize: function() {
                        const e = this;
                        let t, i;
                        const s = e.$el;
                        t = "undefined" !== typeof e.params.width && null !== e.params.width ? e.params.width : s[0].clientWidth, i = "undefined" !== typeof e.params.height && null !== e.params.height ? e.params.height : s[0].clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(s.css("padding-left") || 0, 10) - parseInt(s.css("padding-right") || 0, 10), i = i - parseInt(s.css("padding-top") || 0, 10) - parseInt(s.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(i) && (i = 0), Object.assign(e, {
                            width: t,
                            height: i,
                            size: e.isHorizontal() ? t : i
                        }))
                    },
                    updateSlides: function() {
                        const e = this;

                        function t(t) {
                            return e.isHorizontal() ? t : {
                                width: "height",
                                "margin-top": "margin-left",
                                "margin-bottom ": "margin-right",
                                "margin-left": "margin-top",
                                "margin-right": "margin-bottom",
                                "padding-left": "padding-top",
                                "padding-right": "padding-bottom",
                                marginRight: "marginBottom"
                            }[t]
                        }

                        function i(e, i) {
                            return parseFloat(e.getPropertyValue(t(i)) || 0)
                        }
                        const s = e.params,
                            {
                                $wrapperEl: a,
                                size: r,
                                rtlTranslate: n,
                                wrongRTL: l
                            } = e,
                            o = e.virtual && s.virtual.enabled,
                            p = o ? e.virtual.slides.length : e.slides.length,
                            d = a.children(`.${e.params.slideClass}`),
                            u = o ? e.virtual.slides.length : d.length;
                        let f = [];
                        const g = [],
                            h = [];
                        let w = s.slidesOffsetBefore;
                        "function" === typeof w && (w = s.slidesOffsetBefore.call(e));
                        let m = s.slidesOffsetAfter;
                        "function" === typeof m && (m = s.slidesOffsetAfter.call(e));
                        const v = e.snapGrid.length,
                            b = e.slidesGrid.length;
                        let y = s.spaceBetween,
                            A = -w,
                            C = 0,
                            x = 0;
                        if ("undefined" === typeof r) return;
                        "string" === typeof y && y.indexOf("%") >= 0 && (y = parseFloat(y.replace("%", "")) / 100 * r), e.virtualSize = -y, n ? d.css({
                            marginLeft: "",
                            marginBottom: "",
                            marginTop: ""
                        }) : d.css({
                            marginRight: "",
                            marginBottom: "",
                            marginTop: ""
                        }), s.centeredSlides && s.cssMode && (c(e.wrapperEl, "--swiper-centered-offset-before", ""), c(e.wrapperEl, "--swiper-centered-offset-after", ""));
                        const S = s.grid && s.grid.rows > 1 && e.grid;
                        let E;
                        S && e.grid.initSlides(u);
                        const T = "auto" === s.slidesPerView && s.breakpoints && Object.keys(s.breakpoints).filter((e => "undefined" !== typeof s.breakpoints[e].slidesPerView)).length > 0;
                        for (let a = 0; a < u; a += 1) {
                            E = 0;
                            const n = d.eq(a);
                            if (S && e.grid.updateSlide(a, n, u, t), "none" !== n.css("display")) {
                                if ("auto" === s.slidesPerView) {
                                    T && (d[a].style[t("width")] = "");
                                    const r = getComputedStyle(n[0]),
                                        l = n[0].style.transform,
                                        o = n[0].style.webkitTransform;
                                    if (l && (n[0].style.transform = "none"), o && (n[0].style.webkitTransform = "none"), s.roundLengths) E = e.isHorizontal() ? n.outerWidth(!0) : n.outerHeight(!0);
                                    else {
                                        const e = i(r, "width"),
                                            t = i(r, "padding-left"),
                                            s = i(r, "padding-right"),
                                            a = i(r, "margin-left"),
                                            l = i(r, "margin-right"),
                                            o = r.getPropertyValue("box-sizing");
                                        if (o && "border-box" === o) E = e + a + l;
                                        else {
                                            const {
                                                clientWidth: i,
                                                offsetWidth: r
                                            } = n[0];
                                            E = e + t + s + a + l + (r - i)
                                        }
                                    }
                                    l && (n[0].style.transform = l), o && (n[0].style.webkitTransform = o), s.roundLengths && (E = Math.floor(E))
                                } else E = (r - (s.slidesPerView - 1) * y) / s.slidesPerView, s.roundLengths && (E = Math.floor(E)), d[a] && (d[a].style[t("width")] = `${E}px`);
                                d[a] && (d[a].swiperSlideSize = E), h.push(E), s.centeredSlides ? (A = A + E / 2 + C / 2 + y, 0 === C && 0 !== a && (A = A - r / 2 - y), 0 === a && (A = A - r / 2 - y), Math.abs(A) < .001 && (A = 0), s.roundLengths && (A = Math.floor(A)), x % s.slidesPerGroup === 0 && f.push(A), g.push(A)) : (s.roundLengths && (A = Math.floor(A)), (x - Math.min(e.params.slidesPerGroupSkip, x)) % e.params.slidesPerGroup === 0 && f.push(A), g.push(A), A = A + E + y), e.virtualSize += E + y, C = E, x += 1
                            }
                        }
                        if (e.virtualSize = Math.max(e.virtualSize, r) + m, n && l && ("slide" === s.effect || "coverflow" === s.effect) && a.css({
                                width: `${e.virtualSize+s.spaceBetween}px`
                            }), s.setWrapperSize && a.css({
                                [t("width")]: `${e.virtualSize+s.spaceBetween}px`
                            }), S && e.grid.updateWrapperSize(E, f, t), !s.centeredSlides) {
                            const t = [];
                            for (let i = 0; i < f.length; i += 1) {
                                let a = f[i];
                                s.roundLengths && (a = Math.floor(a)), f[i] <= e.virtualSize - r && t.push(a)
                            }
                            f = t, Math.floor(e.virtualSize - r) - Math.floor(f[f.length - 1]) > 1 && f.push(e.virtualSize - r)
                        }
                        if (0 === f.length && (f = [0]), 0 !== s.spaceBetween) {
                            const i = e.isHorizontal() && n ? "marginLeft" : t("marginRight");
                            d.filter(((e, t) => !s.cssMode || t !== d.length - 1)).css({
                                [i]: `${y}px`
                            })
                        }
                        if (s.centeredSlides && s.centeredSlidesBounds) {
                            let e = 0;
                            h.forEach((t => {
                                e += t + (s.spaceBetween ? s.spaceBetween : 0)
                            })), e -= s.spaceBetween;
                            const t = e - r;
                            f = f.map((e => e < 0 ? -w : e > t ? t + m : e))
                        }
                        if (s.centerInsufficientSlides) {
                            let e = 0;
                            if (h.forEach((t => {
                                    e += t + (s.spaceBetween ? s.spaceBetween : 0)
                                })), e -= s.spaceBetween, e < r) {
                                const t = (r - e) / 2;
                                f.forEach(((e, i) => {
                                    f[i] = e - t
                                })), g.forEach(((e, i) => {
                                    g[i] = e + t
                                }))
                            }
                        }
                        if (Object.assign(e, {
                                slides: d,
                                snapGrid: f,
                                slidesGrid: g,
                                slidesSizesGrid: h
                            }), s.centeredSlides && s.cssMode && !s.centeredSlidesBounds) {
                            c(e.wrapperEl, "--swiper-centered-offset-before", -f[0] + "px"), c(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - h[h.length - 1] / 2 + "px");
                            const t = -e.snapGrid[0],
                                i = -e.slidesGrid[0];
                            e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + i))
                        }
                        if (u !== p && e.emit("slidesLengthChange"), f.length !== v && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), g.length !== b && e.emit("slidesGridLengthChange"), s.watchSlidesProgress && e.updateSlidesOffset(), !o && !s.cssMode && ("slide" === s.effect || "fade" === s.effect)) {
                            const t = `${s.containerModifierClass}backface-hidden`,
                                i = e.$el.hasClass(t);
                            u <= s.maxBackfaceHiddenSlides ? i || e.$el.addClass(t) : i && e.$el.removeClass(t)
                        }
                    },
                    updateAutoHeight: function(e) {
                        const t = this,
                            i = [],
                            s = t.virtual && t.params.virtual.enabled;
                        let a, r = 0;
                        "number" === typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
                        const l = e => s ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0];
                        if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                            if (t.params.centeredSlides)(t.visibleSlides || n([])).each((e => {
                                i.push(e)
                            }));
                            else
                                for (a = 0; a < Math.ceil(t.params.slidesPerView); a += 1) {
                                    const e = t.activeIndex + a;
                                    if (e > t.slides.length && !s) break;
                                    i.push(l(e))
                                } else i.push(l(t.activeIndex));
                        for (a = 0; a < i.length; a += 1)
                            if ("undefined" !== typeof i[a]) {
                                const e = i[a].offsetHeight;
                                r = e > r ? e : r
                            }(r || 0 === r) && t.$wrapperEl.css("height", `${r}px`)
                    },
                    updateSlidesOffset: function() {
                        const e = this,
                            t = e.slides;
                        for (let i = 0; i < t.length; i += 1) t[i].swiperSlideOffset = e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop
                    },
                    updateSlidesProgress: function(e = this && this.translate || 0) {
                        const t = this,
                            i = t.params,
                            {
                                slides: s,
                                rtlTranslate: a,
                                snapGrid: r
                            } = t;
                        if (0 === s.length) return;
                        "undefined" === typeof s[0].swiperSlideOffset && t.updateSlidesOffset();
                        let l = -e;
                        a && (l = e), s.removeClass(i.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = [];
                        for (let e = 0; e < s.length; e += 1) {
                            const n = s[e];
                            let o = n.swiperSlideOffset;
                            i.cssMode && i.centeredSlides && (o -= s[0].swiperSlideOffset);
                            const p = (l + (i.centeredSlides ? t.minTranslate() : 0) - o) / (n.swiperSlideSize + i.spaceBetween),
                                d = (l - r[0] + (i.centeredSlides ? t.minTranslate() : 0) - o) / (n.swiperSlideSize + i.spaceBetween),
                                c = -(l - o),
                                u = c + t.slidesSizesGrid[e];
                            (c >= 0 && c < t.size - 1 || u > 1 && u <= t.size || c <= 0 && u >= t.size) && (t.visibleSlides.push(n), t.visibleSlidesIndexes.push(e), s.eq(e).addClass(i.slideVisibleClass)), n.progress = a ? -p : p, n.originalProgress = a ? -d : d
                        }
                        t.visibleSlides = n(t.visibleSlides)
                    },
                    updateProgress: function(e) {
                        const t = this;
                        if ("undefined" === typeof e) {
                            const i = t.rtlTranslate ? -1 : 1;
                            e = t && t.translate && t.translate * i || 0
                        }
                        const i = t.params,
                            s = t.maxTranslate() - t.minTranslate();
                        let {
                            progress: a,
                            isBeginning: r,
                            isEnd: n
                        } = t;
                        const l = r,
                            o = n;
                        0 === s ? (a = 0, r = !0, n = !0) : (a = (e - t.minTranslate()) / s, r = a <= 0, n = a >= 1), Object.assign(t, {
                            progress: a,
                            isBeginning: r,
                            isEnd: n
                        }), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit("reachBeginning toEdge"), n && !o && t.emit("reachEnd toEdge"), (l && !r || o && !n) && t.emit("fromEdge"), t.emit("progress", a)
                    },
                    updateSlidesClasses: function() {
                        const e = this,
                            {
                                slides: t,
                                params: i,
                                $wrapperEl: s,
                                activeIndex: a,
                                realIndex: r
                            } = e,
                            n = e.virtual && i.virtual.enabled;
                        let l;
                        t.removeClass(`${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`), l = n ? e.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${a}"]`) : t.eq(a), l.addClass(i.slideActiveClass), i.loop && (l.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(i.slideDuplicateActiveClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(i.slideDuplicateActiveClass));
                        let o = l.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass);
                        i.loop && 0 === o.length && (o = t.eq(0), o.addClass(i.slideNextClass));
                        let p = l.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass);
                        i.loop && 0 === p.length && (p = t.eq(-1), p.addClass(i.slidePrevClass)), i.loop && (o.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass), p.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${p.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${p.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass)), e.emitSlidesClasses()
                    },
                    updateActiveIndex: function(e) {
                        const t = this,
                            i = t.rtlTranslate ? t.translate : -t.translate,
                            {
                                slidesGrid: s,
                                snapGrid: a,
                                params: r,
                                activeIndex: n,
                                realIndex: l,
                                snapIndex: o
                            } = t;
                        let p, d = e;
                        if ("undefined" === typeof d) {
                            for (let e = 0; e < s.length; e += 1) "undefined" !== typeof s[e + 1] ? i >= s[e] && i < s[e + 1] - (s[e + 1] - s[e]) / 2 ? d = e : i >= s[e] && i < s[e + 1] && (d = e + 1) : i >= s[e] && (d = e);
                            r.normalizeSlideIndex && (d < 0 || "undefined" === typeof d) && (d = 0)
                        }
                        if (a.indexOf(i) >= 0) p = a.indexOf(i);
                        else {
                            const e = Math.min(r.slidesPerGroupSkip, d);
                            p = e + Math.floor((d - e) / r.slidesPerGroup)
                        }
                        if (p >= a.length && (p = a.length - 1), d === n) return void(p !== o && (t.snapIndex = p, t.emit("snapIndexChange")));
                        const c = parseInt(t.slides.eq(d).attr("data-swiper-slide-index") || d, 10);
                        Object.assign(t, {
                            snapIndex: p,
                            realIndex: c,
                            previousIndex: n,
                            activeIndex: d
                        }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), l !== c && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange")
                    },
                    updateClickedSlide: function(e) {
                        const t = this,
                            i = t.params,
                            s = n(e).closest(`.${i.slideClass}`)[0];
                        let a, r = !1;
                        if (s)
                            for (let e = 0; e < t.slides.length; e += 1)
                                if (t.slides[e] === s) {
                                    r = !0, a = e;
                                    break
                                }
                        if (!s || !r) return t.clickedSlide = void 0, void(t.clickedIndex = void 0);
                        t.clickedSlide = s, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(n(s).attr("data-swiper-slide-index"), 10) : t.clickedIndex = a, i.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
                    }
                };

            function b({
                swiper: e,
                runCallbacks: t,
                direction: i,
                step: s
            }) {
                const {
                    activeIndex: a,
                    previousIndex: r
                } = e;
                let n = i;
                if (n || (n = a > r ? "next" : a < r ? "prev" : "reset"), e.emit(`transition${s}`), t && a !== r) {
                    if ("reset" === n) return void e.emit(`slideResetTransition${s}`);
                    e.emit(`slideChangeTransition${s}`), "next" === n ? e.emit(`slideNextTransition${s}`) : e.emit(`slidePrevTransition${s}`)
                }
            }
            const y = {
                slideTo: function(e = 0, t = this.params.speed, i = !0, s, a) {
                    if ("number" !== typeof e && "string" !== typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`);
                    if ("string" === typeof e) {
                        const t = parseInt(e, 10);
                        if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
                        e = t
                    }
                    const r = this;
                    let n = e;
                    n < 0 && (n = 0);
                    const {
                        params: l,
                        snapGrid: o,
                        slidesGrid: p,
                        previousIndex: d,
                        activeIndex: c,
                        rtlTranslate: f,
                        wrapperEl: g,
                        enabled: h
                    } = r;
                    if (r.animating && l.preventInteractionOnTransition || !h && !s && !a) return !1;
                    const w = Math.min(r.params.slidesPerGroupSkip, n);
                    let m = w + Math.floor((n - w) / r.params.slidesPerGroup);
                    m >= o.length && (m = o.length - 1);
                    const v = -o[m];
                    if (l.normalizeSlideIndex)
                        for (let e = 0; e < p.length; e += 1) {
                            const t = -Math.floor(100 * v),
                                i = Math.floor(100 * p[e]),
                                s = Math.floor(100 * p[e + 1]);
                            "undefined" !== typeof p[e + 1] ? t >= i && t < s - (s - i) / 2 ? n = e : t >= i && t < s && (n = e + 1) : t >= i && (n = e)
                        }
                    if (r.initialized && n !== c) {
                        if (!r.allowSlideNext && v < r.translate && v < r.minTranslate()) return !1;
                        if (!r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (c || 0) !== n) return !1
                    }
                    let b;
                    if (n !== (d || 0) && i && r.emit("beforeSlideChangeStart"), r.updateProgress(v), b = n > c ? "next" : n < c ? "prev" : "reset", f && -v === r.translate || !f && v === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(v), "reset" !== b && (r.transitionStart(i, b), r.transitionEnd(i, b)), !1;
                    if (l.cssMode) {
                        const e = r.isHorizontal(),
                            i = f ? v : -v;
                        if (0 === t) {
                            const t = r.virtual && r.params.virtual.enabled;
                            t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), g[e ? "scrollLeft" : "scrollTop"] = i, t && requestAnimationFrame((() => {
                                r.wrapperEl.style.scrollSnapType = "", r._swiperImmediateVirtual = !1
                            }))
                        } else {
                            if (!r.support.smoothScroll) return u({
                                swiper: r,
                                targetPosition: i,
                                side: e ? "left" : "top"
                            }), !0;
                            g.scrollTo({
                                [e ? "left" : "top"]: i,
                                behavior: "smooth"
                            })
                        }
                        return !0
                    }
                    return r.setTransition(t), r.setTranslate(v), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, s), r.transitionStart(i, b), 0 === t ? r.transitionEnd(i, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(e) {
                        r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(i, b))
                    }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd)), !0
                },
                slideToLoop: function(e = 0, t = this.params.speed, i = !0, s) {
                    if ("string" === typeof e) {
                        const t = parseInt(e, 10);
                        if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
                        e = t
                    }
                    const a = this;
                    let r = e;
                    return a.params.loop && (r += a.loopedSlides), a.slideTo(r, t, i, s)
                },
                slideNext: function(e = this.params.speed, t = !0, i) {
                    const s = this,
                        {
                            animating: a,
                            enabled: r,
                            params: n
                        } = s;
                    if (!r) return s;
                    let l = n.slidesPerGroup;
                    "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (l = Math.max(s.slidesPerViewDynamic("current", !0), 1));
                    const o = s.activeIndex < n.slidesPerGroupSkip ? 1 : l;
                    if (n.loop) {
                        if (a && n.loopPreventsSlide) return !1;
                        s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft
                    }
                    return n.rewind && s.isEnd ? s.slideTo(0, e, t, i) : s.slideTo(s.activeIndex + o, e, t, i)
                },
                slidePrev: function(e = this.params.speed, t = !0, i) {
                    const s = this,
                        {
                            params: a,
                            animating: r,
                            snapGrid: n,
                            slidesGrid: l,
                            rtlTranslate: o,
                            enabled: p
                        } = s;
                    if (!p) return s;
                    if (a.loop) {
                        if (r && a.loopPreventsSlide) return !1;
                        s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft
                    }

                    function d(e) {
                        return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
                    }
                    const c = d(o ? s.translate : -s.translate),
                        u = n.map((e => d(e)));
                    let f = n[u.indexOf(c) - 1];
                    if ("undefined" === typeof f && a.cssMode) {
                        let e;
                        n.forEach(((t, i) => {
                            c >= t && (e = i)
                        })), "undefined" !== typeof e && (f = n[e > 0 ? e - 1 : e])
                    }
                    let g = 0;
                    if ("undefined" !== typeof f && (g = l.indexOf(f), g < 0 && (g = s.activeIndex - 1), "auto" === a.slidesPerView && 1 === a.slidesPerGroup && a.slidesPerGroupAuto && (g = g - s.slidesPerViewDynamic("previous", !0) + 1, g = Math.max(g, 0))), a.rewind && s.isBeginning) {
                        const a = s.params.virtual && s.params.virtual.enabled && s.virtual ? s.virtual.slides.length - 1 : s.slides.length - 1;
                        return s.slideTo(a, e, t, i)
                    }
                    return s.slideTo(g, e, t, i)
                },
                slideReset: function(e = this.params.speed, t = !0, i) {
                    return this.slideTo(this.activeIndex, e, t, i)
                },
                slideToClosest: function(e = this.params.speed, t = !0, i, s = .5) {
                    const a = this;
                    let r = a.activeIndex;
                    const n = Math.min(a.params.slidesPerGroupSkip, r),
                        l = n + Math.floor((r - n) / a.params.slidesPerGroup),
                        o = a.rtlTranslate ? a.translate : -a.translate;
                    if (o >= a.snapGrid[l]) {
                        const e = a.snapGrid[l];
                        o - e > (a.snapGrid[l + 1] - e) * s && (r += a.params.slidesPerGroup)
                    } else {
                        const e = a.snapGrid[l - 1];
                        o - e <= (a.snapGrid[l] - e) * s && (r -= a.params.slidesPerGroup)
                    }
                    return r = Math.max(r, 0), r = Math.min(r, a.slidesGrid.length - 1), a.slideTo(r, e, t, i)
                },
                slideToClickedSlide: function() {
                    const e = this,
                        {
                            params: t,
                            $wrapperEl: i
                        } = e,
                        s = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
                    let a, r = e.clickedIndex;
                    if (t.loop) {
                        if (e.animating) return;
                        a = parseInt(n(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - s / 2 || r > e.slides.length - e.loopedSlides + s / 2 ? (e.loopFix(), r = i.children(`.${t.slideClass}[data-swiper-slide-index="${a}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), l((() => {
                            e.slideTo(r)
                        }))) : e.slideTo(r) : r > e.slides.length - s ? (e.loopFix(), r = i.children(`.${t.slideClass}[data-swiper-slide-index="${a}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), l((() => {
                            e.slideTo(r)
                        }))) : e.slideTo(r)
                    } else e.slideTo(r)
                }
            };

            function A(e) {
                const t = this,
                    i = (0, s.Me)(),
                    a = (0, s.Jj)(),
                    r = t.touchEventsData,
                    {
                        params: l,
                        touches: p,
                        enabled: d
                    } = t;
                if (!d) return;
                if (t.animating && l.preventInteractionOnTransition) return;
                !t.animating && l.cssMode && l.loop && t.loopFix();
                let c = e;
                c.originalEvent && (c = c.originalEvent);
                let u = n(c.target);
                if ("wrapper" === l.touchEventsTarget && !u.closest(t.wrapperEl).length) return;
                if (r.isTouchEvent = "touchstart" === c.type, !r.isTouchEvent && "which" in c && 3 === c.which) return;
                if (!r.isTouchEvent && "button" in c && c.button > 0) return;
                if (r.isTouched && r.isMoved) return;
                const f = !!l.noSwipingClass && "" !== l.noSwipingClass,
                    g = e.composedPath ? e.composedPath() : e.path;
                f && c.target && c.target.shadowRoot && g && (u = n(g[0]));
                const h = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`,
                    w = !(!c.target || !c.target.shadowRoot);
                if (l.noSwiping && (w ? function(e, t = this) {
                        return function t(i) {
                            if (!i || i === (0, s.Me)() || i === (0, s.Jj)()) return null;
                            i.assignedSlot && (i = i.assignedSlot);
                            const a = i.closest(e);
                            return a || i.getRootNode ? a || t(i.getRootNode().host) : null
                        }(t)
                    }(h, u[0]) : u.closest(h)[0])) return void(t.allowClick = !0);
                if (l.swipeHandler && !u.closest(l.swipeHandler)[0]) return;
                p.currentX = "touchstart" === c.type ? c.targetTouches[0].pageX : c.pageX, p.currentY = "touchstart" === c.type ? c.targetTouches[0].pageY : c.pageY;
                const m = p.currentX,
                    v = p.currentY,
                    b = l.edgeSwipeDetection || l.iOSEdgeSwipeDetection,
                    y = l.edgeSwipeThreshold || l.iOSEdgeSwipeThreshold;
                if (b && (m <= y || m >= a.innerWidth - y)) {
                    if ("prevent" !== b) return;
                    e.preventDefault()
                }
                if (Object.assign(r, {
                        isTouched: !0,
                        isMoved: !1,
                        allowTouchCallbacks: !0,
                        isScrolling: void 0,
                        startMoving: void 0
                    }), p.startX = m, p.startY = v, r.touchStartTime = o(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (r.allowThresholdMove = !1), "touchstart" !== c.type) {
                    let e = !0;
                    u.is(r.focusableElements) && (e = !1, "SELECT" === u[0].nodeName && (r.isTouched = !1)), i.activeElement && n(i.activeElement).is(r.focusableElements) && i.activeElement !== u[0] && i.activeElement.blur();
                    const s = e && t.allowTouchMove && l.touchStartPreventDefault;
                    !l.touchStartForcePreventDefault && !s || u[0].isContentEditable || c.preventDefault()
                }
                t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !l.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", c)
            }

            function C(e) {
                const t = (0, s.Me)(),
                    i = this,
                    a = i.touchEventsData,
                    {
                        params: r,
                        touches: l,
                        rtlTranslate: p,
                        enabled: d
                    } = i;
                if (!d) return;
                let c = e;
                if (c.originalEvent && (c = c.originalEvent), !a.isTouched) return void(a.startMoving && a.isScrolling && i.emit("touchMoveOpposite", c));
                if (a.isTouchEvent && "touchmove" !== c.type) return;
                const u = "touchmove" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]),
                    f = "touchmove" === c.type ? u.pageX : c.pageX,
                    g = "touchmove" === c.type ? u.pageY : c.pageY;
                if (c.preventedByNestedSwiper) return l.startX = f, void(l.startY = g);
                if (!i.allowTouchMove) return n(c.target).is(a.focusableElements) || (i.allowClick = !1), void(a.isTouched && (Object.assign(l, {
                    startX: f,
                    startY: g,
                    currentX: f,
                    currentY: g
                }), a.touchStartTime = o()));
                if (a.isTouchEvent && r.touchReleaseOnEdges && !r.loop)
                    if (i.isVertical()) {
                        if (g < l.startY && i.translate <= i.maxTranslate() || g > l.startY && i.translate >= i.minTranslate()) return a.isTouched = !1, void(a.isMoved = !1)
                    } else if (f < l.startX && i.translate <= i.maxTranslate() || f > l.startX && i.translate >= i.minTranslate()) return;
                if (a.isTouchEvent && t.activeElement && c.target === t.activeElement && n(c.target).is(a.focusableElements)) return a.isMoved = !0, void(i.allowClick = !1);
                if (a.allowTouchCallbacks && i.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1) return;
                l.currentX = f, l.currentY = g;
                const h = l.currentX - l.startX,
                    w = l.currentY - l.startY;
                if (i.params.threshold && Math.sqrt(h ** 2 + w ** 2) < i.params.threshold) return;
                if ("undefined" === typeof a.isScrolling) {
                    let e;
                    i.isHorizontal() && l.currentY === l.startY || i.isVertical() && l.currentX === l.startX ? a.isScrolling = !1 : h * h + w * w >= 25 && (e = 180 * Math.atan2(Math.abs(w), Math.abs(h)) / Math.PI, a.isScrolling = i.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle)
                }
                if (a.isScrolling && i.emit("touchMoveOpposite", c), "undefined" === typeof a.startMoving && (l.currentX === l.startX && l.currentY === l.startY || (a.startMoving = !0)), a.isScrolling) return void(a.isTouched = !1);
                if (!a.startMoving) return;
                i.allowClick = !1, !r.cssMode && c.cancelable && c.preventDefault(), r.touchMoveStopPropagation && !r.nested && c.stopPropagation(), a.isMoved || (r.loop && !r.cssMode && i.loopFix(), a.startTranslate = i.getTranslate(), i.setTransition(0), i.animating && i.$wrapperEl.trigger("webkitTransitionEnd transitionend"), a.allowMomentumBounce = !1, !r.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0), i.emit("sliderFirstMove", c)), i.emit("sliderMove", c), a.isMoved = !0;
                let m = i.isHorizontal() ? h : w;
                l.diff = m, m *= r.touchRatio, p && (m = -m), i.swipeDirection = m > 0 ? "prev" : "next", a.currentTranslate = m + a.startTranslate;
                let v = !0,
                    b = r.resistanceRatio;
                if (r.touchReleaseOnEdges && (b = 0), m > 0 && a.currentTranslate > i.minTranslate() ? (v = !1, r.resistance && (a.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + a.startTranslate + m) ** b)) : m < 0 && a.currentTranslate < i.maxTranslate() && (v = !1, r.resistance && (a.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - a.startTranslate - m) ** b)), v && (c.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && a.currentTranslate < a.startTranslate && (a.currentTranslate = a.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && a.currentTranslate > a.startTranslate && (a.currentTranslate = a.startTranslate), i.allowSlidePrev || i.allowSlideNext || (a.currentTranslate = a.startTranslate), r.threshold > 0) {
                    if (!(Math.abs(m) > r.threshold || a.allowThresholdMove)) return void(a.currentTranslate = a.startTranslate);
                    if (!a.allowThresholdMove) return a.allowThresholdMove = !0, l.startX = l.currentX, l.startY = l.currentY, a.currentTranslate = a.startTranslate, void(l.diff = i.isHorizontal() ? l.currentX - l.startX : l.currentY - l.startY)
                }
                r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && i.freeMode || r.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), i.params.freeMode && r.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(a.currentTranslate), i.setTranslate(a.currentTranslate))
            }

            function x(e) {
                const t = this,
                    i = t.touchEventsData,
                    {
                        params: s,
                        touches: a,
                        rtlTranslate: r,
                        slidesGrid: n,
                        enabled: p
                    } = t;
                if (!p) return;
                let d = e;
                if (d.originalEvent && (d = d.originalEvent), i.allowTouchCallbacks && t.emit("touchEnd", d), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && s.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void(i.startMoving = !1);
                s.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
                const c = o(),
                    u = c - i.touchStartTime;
                if (t.allowClick) {
                    const e = d.path || d.composedPath && d.composedPath();
                    t.updateClickedSlide(e && e[0] || d.target), t.emit("tap click", d), u < 300 && c - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", d)
                }
                if (i.lastClickTime = o(), l((() => {
                        t.destroyed || (t.allowClick = !0)
                    })), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === a.diff || i.currentTranslate === i.startTranslate) return i.isTouched = !1, i.isMoved = !1, void(i.startMoving = !1);
                let f;
                if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, f = s.followFinger ? r ? t.translate : -t.translate : -i.currentTranslate, s.cssMode) return;
                if (t.params.freeMode && s.freeMode.enabled) return void t.freeMode.onTouchEnd({
                    currentPos: f
                });
                let g = 0,
                    h = t.slidesSizesGrid[0];
                for (let e = 0; e < n.length; e += e < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) {
                    const t = e < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup;
                    "undefined" !== typeof n[e + t] ? f >= n[e] && f < n[e + t] && (g = e, h = n[e + t] - n[e]) : f >= n[e] && (g = e, h = n[n.length - 1] - n[n.length - 2])
                }
                let w = null,
                    m = null;
                s.rewind && (t.isBeginning ? m = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (w = 0));
                const v = (f - n[g]) / h,
                    b = g < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup;
                if (u > s.longSwipesMs) {
                    if (!s.longSwipes) return void t.slideTo(t.activeIndex);
                    "next" === t.swipeDirection && (v >= s.longSwipesRatio ? t.slideTo(s.rewind && t.isEnd ? w : g + b) : t.slideTo(g)), "prev" === t.swipeDirection && (v > 1 - s.longSwipesRatio ? t.slideTo(g + b) : null !== m && v < 0 && Math.abs(v) > s.longSwipesRatio ? t.slideTo(m) : t.slideTo(g))
                } else {
                    if (!s.shortSwipes) return void t.slideTo(t.activeIndex);
                    !t.navigation || d.target !== t.navigation.nextEl && d.target !== t.navigation.prevEl ? ("next" === t.swipeDirection && t.slideTo(null !== w ? w : g + b), "prev" === t.swipeDirection && t.slideTo(null !== m ? m : g)) : d.target === t.navigation.nextEl ? t.slideTo(g + b) : t.slideTo(g)
                }
            }

            function S() {
                const e = this,
                    {
                        params: t,
                        el: i
                    } = e;
                if (i && 0 === i.offsetWidth) return;
                t.breakpoints && e.setBreakpoint();
                const {
                    allowSlideNext: s,
                    allowSlidePrev: a,
                    snapGrid: r
                } = e;
                e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = a, e.allowSlideNext = s, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow()
            }

            function E(e) {
                const t = this;
                t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
            }

            function T() {
                const e = this,
                    {
                        wrapperEl: t,
                        rtlTranslate: i,
                        enabled: s
                    } = e;
                if (!s) return;
                let a;
                e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
                const r = e.maxTranslate() - e.minTranslate();
                a = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, a !== e.progress && e.updateProgress(i ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
            }
            let k = !1;

            function M() {}
            const P = (e, t) => {
                    const i = (0, s.Me)(),
                        {
                            params: a,
                            touchEvents: r,
                            el: n,
                            wrapperEl: l,
                            device: o,
                            support: p
                        } = e,
                        d = !!a.nested,
                        c = "on" === t ? "addEventListener" : "removeEventListener",
                        u = t;
                    if (p.touch) {
                        const t = !("touchstart" !== r.start || !p.passiveListener || !a.passiveListeners) && {
                            passive: !0,
                            capture: !1
                        };
                        n[c](r.start, e.onTouchStart, t), n[c](r.move, e.onTouchMove, p.passiveListener ? {
                            passive: !1,
                            capture: d
                        } : d), n[c](r.end, e.onTouchEnd, t), r.cancel && n[c](r.cancel, e.onTouchEnd, t)
                    } else n[c](r.start, e.onTouchStart, !1), i[c](r.move, e.onTouchMove, d), i[c](r.end, e.onTouchEnd, !1);
                    (a.preventClicks || a.preventClicksPropagation) && n[c]("click", e.onClick, !0), a.cssMode && l[c]("scroll", e.onScroll), a.updateOnWindowResize ? e[u](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", S, !0) : e[u]("observerUpdate", S, !0)
                },
                $ = {
                    attachEvents: function() {
                        const e = this,
                            t = (0, s.Me)(),
                            {
                                params: i,
                                support: a
                            } = e;
                        e.onTouchStart = A.bind(e), e.onTouchMove = C.bind(e), e.onTouchEnd = x.bind(e), i.cssMode && (e.onScroll = T.bind(e)), e.onClick = E.bind(e), a.touch && !k && (t.addEventListener("touchstart", M), k = !0), P(e, "on")
                    },
                    detachEvents: function() {
                        P(this, "off")
                    }
                },
                z = (e, t) => e.grid && t.grid && t.grid.rows > 1,
                O = {
                    addClasses: function() {
                        const e = this,
                            {
                                classNames: t,
                                params: i,
                                rtl: s,
                                $el: a,
                                device: r,
                                support: n
                            } = e,
                            l = function(e, t) {
                                const i = [];
                                return e.forEach((e => {
                                    "object" === typeof e ? Object.keys(e).forEach((s => {
                                        e[s] && i.push(t + s)
                                    })) : "string" === typeof e && i.push(t + e)
                                })), i
                            }(["initialized", i.direction, {
                                "pointer-events": !n.touch
                            }, {
                                "free-mode": e.params.freeMode && i.freeMode.enabled
                            }, {
                                autoheight: i.autoHeight
                            }, {
                                rtl: s
                            }, {
                                grid: i.grid && i.grid.rows > 1
                            }, {
                                "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill
                            }, {
                                android: r.android
                            }, {
                                ios: r.ios
                            }, {
                                "css-mode": i.cssMode
                            }, {
                                centered: i.cssMode && i.centeredSlides
                            }, {
                                "watch-progress": i.watchSlidesProgress
                            }], i.containerModifierClass);
                        t.push(...l), a.addClass([...t].join(" ")), e.emitContainerClasses()
                    },
                    removeClasses: function() {
                        const {
                            $el: e,
                            classNames: t
                        } = this;
                        e.removeClass(t.join(" ")), this.emitContainerClasses()
                    }
                },
                I = {
                    init: !0,
                    direction: "horizontal",
                    touchEventsTarget: "wrapper",
                    initialSlide: 0,
                    speed: 300,
                    cssMode: !1,
                    updateOnWindowResize: !0,
                    resizeObserver: !0,
                    nested: !1,
                    createElements: !1,
                    enabled: !0,
                    focusableElements: "input, select, option, textarea, button, video, label",
                    width: null,
                    height: null,
                    preventInteractionOnTransition: !1,
                    userAgent: null,
                    url: null,
                    edgeSwipeDetection: !1,
                    edgeSwipeThreshold: 20,
                    autoHeight: !1,
                    setWrapperSize: !1,
                    virtualTranslate: !1,
                    effect: "slide",
                    breakpoints: void 0,
                    breakpointsBase: "window",
                    spaceBetween: 0,
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    slidesPerGroupSkip: 0,
                    slidesPerGroupAuto: !1,
                    centeredSlides: !1,
                    centeredSlidesBounds: !1,
                    slidesOffsetBefore: 0,
                    slidesOffsetAfter: 0,
                    normalizeSlideIndex: !0,
                    centerInsufficientSlides: !1,
                    watchOverflow: !0,
                    roundLengths: !1,
                    touchRatio: 1,
                    touchAngle: 45,
                    simulateTouch: !0,
                    shortSwipes: !0,
                    longSwipes: !0,
                    longSwipesRatio: .5,
                    longSwipesMs: 300,
                    followFinger: !0,
                    allowTouchMove: !0,
                    threshold: 0,
                    touchMoveStopPropagation: !1,
                    touchStartPreventDefault: !0,
                    touchStartForcePreventDefault: !1,
                    touchReleaseOnEdges: !1,
                    uniqueNavElements: !0,
                    resistance: !0,
                    resistanceRatio: .85,
                    watchSlidesProgress: !1,
                    grabCursor: !1,
                    preventClicks: !0,
                    preventClicksPropagation: !0,
                    slideToClickedSlide: !1,
                    preloadImages: !0,
                    updateOnImagesReady: !0,
                    loop: !1,
                    loopAdditionalSlides: 0,
                    loopedSlides: null,
                    loopedSlidesLimit: !0,
                    loopFillGroupWithBlank: !1,
                    loopPreventsSlide: !0,
                    rewind: !1,
                    allowSlidePrev: !0,
                    allowSlideNext: !0,
                    swipeHandler: null,
                    noSwiping: !0,
                    noSwipingClass: "swiper-no-swiping",
                    noSwipingSelector: null,
                    passiveListeners: !0,
                    maxBackfaceHiddenSlides: 10,
                    containerModifierClass: "swiper-",
                    slideClass: "swiper-slide",
                    slideBlankClass: "swiper-slide-invisible-blank",
                    slideActiveClass: "swiper-slide-active",
                    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
                    slideVisibleClass: "swiper-slide-visible",
                    slideDuplicateClass: "swiper-slide-duplicate",
                    slideNextClass: "swiper-slide-next",
                    slideDuplicateNextClass: "swiper-slide-duplicate-next",
                    slidePrevClass: "swiper-slide-prev",
                    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
                    wrapperClass: "swiper-wrapper",
                    runCallbacksOnInit: !0,
                    _emitClasses: !1
                };

            function B(e, t) {
                return function(i = {}) {
                    const s = Object.keys(i)[0],
                        a = i[s];
                    "object" === typeof a && null !== a ? (["navigation", "pagination", "scrollbar"].indexOf(s) >= 0 && !0 === e[s] && (e[s] = {
                        auto: !0
                    }), s in e && "enabled" in a ? (!0 === e[s] && (e[s] = {
                        enabled: !0
                    }), "object" !== typeof e[s] || "enabled" in e[s] || (e[s].enabled = !0), e[s] || (e[s] = {
                        enabled: !1
                    }), d(t, i)) : d(t, i)) : d(t, i)
                }
            }
            const L = {
                    eventsEmitter: m,
                    update: v,
                    translate: {
                        getTranslate: function(e = (this.isHorizontal() ? "x" : "y")) {
                            const {
                                params: t,
                                rtlTranslate: i,
                                translate: a,
                                $wrapperEl: r
                            } = this;
                            if (t.virtualTranslate) return i ? -a : a;
                            if (t.cssMode) return a;
                            let n = function(e, t = "x") {
                                const i = (0, s.Jj)();
                                let a, r, n;
                                const l = function(e) {
                                    const t = (0, s.Jj)();
                                    let i;
                                    return t.getComputedStyle && (i = t.getComputedStyle(e, null)), !i && e.currentStyle && (i = e.currentStyle), i || (i = e.style), i
                                }(e);
                                return i.WebKitCSSMatrix ? (r = l.transform || l.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map((e => e.replace(",", "."))).join(", ")), n = new i.WebKitCSSMatrix("none" === r ? "" : r)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = n.toString().split(",")), "x" === t && (r = i.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (r = i.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), r || 0
                            }(r[0], e);
                            return i && (n = -n), n || 0
                        },
                        setTranslate: function(e, t) {
                            const i = this,
                                {
                                    rtlTranslate: s,
                                    params: a,
                                    $wrapperEl: r,
                                    wrapperEl: n,
                                    progress: l
                                } = i;
                            let o, p = 0,
                                d = 0;
                            i.isHorizontal() ? p = s ? -e : e : d = e, a.roundLengths && (p = Math.floor(p), d = Math.floor(d)), a.cssMode ? n[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -p : -d : a.virtualTranslate || r.transform(`translate3d(${p}px, ${d}px, 0px)`), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? p : d;
                            const c = i.maxTranslate() - i.minTranslate();
                            o = 0 === c ? 0 : (e - i.minTranslate()) / c, o !== l && i.updateProgress(e), i.emit("setTranslate", i.translate, t)
                        },
                        minTranslate: function() {
                            return -this.snapGrid[0]
                        },
                        maxTranslate: function() {
                            return -this.snapGrid[this.snapGrid.length - 1]
                        },
                        translateTo: function(e = 0, t = this.params.speed, i = !0, s = !0, a) {
                            const r = this,
                                {
                                    params: n,
                                    wrapperEl: l
                                } = r;
                            if (r.animating && n.preventInteractionOnTransition) return !1;
                            const o = r.minTranslate(),
                                p = r.maxTranslate();
                            let d;
                            if (d = s && e > o ? o : s && e < p ? p : e, r.updateProgress(d), n.cssMode) {
                                const e = r.isHorizontal();
                                if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -d;
                                else {
                                    if (!r.support.smoothScroll) return u({
                                        swiper: r,
                                        targetPosition: -d,
                                        side: e ? "left" : "top"
                                    }), !0;
                                    l.scrollTo({
                                        [e ? "left" : "top"]: -d,
                                        behavior: "smooth"
                                    })
                                }
                                return !0
                            }
                            return 0 === t ? (r.setTransition(0), r.setTranslate(d), i && (r.emit("beforeTransitionStart", t, a), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(d), i && (r.emit("beforeTransitionStart", t, a), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function(e) {
                                r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, i && r.emit("transitionEnd"))
                            }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0
                        }
                    },
                    transition: {
                        setTransition: function(e, t) {
                            const i = this;
                            i.params.cssMode || i.$wrapperEl.transition(e), i.emit("setTransition", e, t)
                        },
                        transitionStart: function(e = !0, t) {
                            const i = this,
                                {
                                    params: s
                                } = i;
                            s.cssMode || (s.autoHeight && i.updateAutoHeight(), b({
                                swiper: i,
                                runCallbacks: e,
                                direction: t,
                                step: "Start"
                            }))
                        },
                        transitionEnd: function(e = !0, t) {
                            const i = this,
                                {
                                    params: s
                                } = i;
                            i.animating = !1, s.cssMode || (i.setTransition(0), b({
                                swiper: i,
                                runCallbacks: e,
                                direction: t,
                                step: "End"
                            }))
                        }
                    },
                    slide: y,
                    loop: {
                        loopCreate: function() {
                            const e = this,
                                t = (0, s.Me)(),
                                {
                                    params: i,
                                    $wrapperEl: a
                                } = e,
                                r = a.children().length > 0 ? n(a.children()[0].parentNode) : a;
                            r.children(`.${i.slideClass}.${i.slideDuplicateClass}`).remove();
                            let l = r.children(`.${i.slideClass}`);
                            if (i.loopFillGroupWithBlank) {
                                const e = i.slidesPerGroup - l.length % i.slidesPerGroup;
                                if (e !== i.slidesPerGroup) {
                                    for (let s = 0; s < e; s += 1) {
                                        const e = n(t.createElement("div")).addClass(`${i.slideClass} ${i.slideBlankClass}`);
                                        r.append(e)
                                    }
                                    l = r.children(`.${i.slideClass}`)
                                }
                            }
                            "auto" !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = l.length), e.loopedSlides = Math.ceil(parseFloat(i.loopedSlides || i.slidesPerView, 10)), e.loopedSlides += i.loopAdditionalSlides, e.loopedSlides > l.length && e.params.loopedSlidesLimit && (e.loopedSlides = l.length);
                            const o = [],
                                p = [];
                            l.each(((e, t) => {
                                n(e).attr("data-swiper-slide-index", t)
                            }));
                            for (let t = 0; t < e.loopedSlides; t += 1) {
                                const e = t - Math.floor(t / l.length) * l.length;
                                p.push(l.eq(e)[0]), o.unshift(l.eq(l.length - e - 1)[0])
                            }
                            for (let e = 0; e < p.length; e += 1) r.append(n(p[e].cloneNode(!0)).addClass(i.slideDuplicateClass));
                            for (let e = o.length - 1; e >= 0; e -= 1) r.prepend(n(o[e].cloneNode(!0)).addClass(i.slideDuplicateClass))
                        },
                        loopFix: function() {
                            const e = this;
                            e.emit("beforeLoopFix");
                            const {
                                activeIndex: t,
                                slides: i,
                                loopedSlides: s,
                                allowSlidePrev: a,
                                allowSlideNext: r,
                                snapGrid: n,
                                rtlTranslate: l
                            } = e;
                            let o;
                            e.allowSlidePrev = !0, e.allowSlideNext = !0;
                            const p = -n[t] - e.getTranslate();
                            t < s ? (o = i.length - 3 * s + t, o += s, e.slideTo(o, 0, !1, !0) && 0 !== p && e.setTranslate((l ? -e.translate : e.translate) - p)) : t >= i.length - s && (o = -i.length + t + s, o += s, e.slideTo(o, 0, !1, !0) && 0 !== p && e.setTranslate((l ? -e.translate : e.translate) - p)), e.allowSlidePrev = a, e.allowSlideNext = r, e.emit("loopFix")
                        },
                        loopDestroy: function() {
                            const {
                                $wrapperEl: e,
                                params: t,
                                slides: i
                            } = this;
                            e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), i.removeAttr("data-swiper-slide-index")
                        }
                    },
                    grabCursor: {
                        setGrabCursor: function(e) {
                            const t = this;
                            if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
                            const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                            i.style.cursor = "move", i.style.cursor = e ? "grabbing" : "grab"
                        },
                        unsetGrabCursor: function() {
                            const e = this;
                            e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "")
                        }
                    },
                    events: $,
                    breakpoints: {
                        setBreakpoint: function() {
                            const e = this,
                                {
                                    activeIndex: t,
                                    initialized: i,
                                    loopedSlides: s = 0,
                                    params: a,
                                    $el: r
                                } = e,
                                n = a.breakpoints;
                            if (!n || n && 0 === Object.keys(n).length) return;
                            const l = e.getBreakpoint(n, e.params.breakpointsBase, e.el);
                            if (!l || e.currentBreakpoint === l) return;
                            const o = (l in n ? n[l] : void 0) || e.originalParams,
                                p = z(e, a),
                                c = z(e, o),
                                u = a.enabled;
                            p && !c ? (r.removeClass(`${a.containerModifierClass}grid ${a.containerModifierClass}grid-column`), e.emitContainerClasses()) : !p && c && (r.addClass(`${a.containerModifierClass}grid`), (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === a.grid.fill) && r.addClass(`${a.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => {
                                const i = a[t] && a[t].enabled,
                                    s = o[t] && o[t].enabled;
                                i && !s && e[t].disable(), !i && s && e[t].enable()
                            }));
                            const f = o.direction && o.direction !== a.direction,
                                g = a.loop && (o.slidesPerView !== a.slidesPerView || f);
                            f && i && e.changeDirection(), d(e.params, o);
                            const h = e.params.enabled;
                            Object.assign(e, {
                                allowTouchMove: e.params.allowTouchMove,
                                allowSlideNext: e.params.allowSlideNext,
                                allowSlidePrev: e.params.allowSlidePrev
                            }), u && !h ? e.disable() : !u && h && e.enable(), e.currentBreakpoint = l, e.emit("_beforeBreakpoint", o), g && i && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - s + e.loopedSlides, 0, !1)), e.emit("breakpoint", o)
                        },
                        getBreakpoint: function(e, t = "window", i) {
                            if (!e || "container" === t && !i) return;
                            let a = !1;
                            const r = (0, s.Jj)(),
                                n = "window" === t ? r.innerHeight : i.clientHeight,
                                l = Object.keys(e).map((e => {
                                    if ("string" === typeof e && 0 === e.indexOf("@")) {
                                        const t = parseFloat(e.substr(1));
                                        return {
                                            value: n * t,
                                            point: e
                                        }
                                    }
                                    return {
                                        value: e,
                                        point: e
                                    }
                                }));
                            l.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
                            for (let e = 0; e < l.length; e += 1) {
                                const {
                                    point: s,
                                    value: n
                                } = l[e];
                                "window" === t ? r.matchMedia(`(min-width: ${n}px)`).matches && (a = s) : n <= i.clientWidth && (a = s)
                            }
                            return a || "max"
                        }
                    },
                    checkOverflow: {
                        checkOverflow: function() {
                            const e = this,
                                {
                                    isLocked: t,
                                    params: i
                                } = e,
                                {
                                    slidesOffsetBefore: s
                                } = i;
                            if (s) {
                                const t = e.slides.length - 1,
                                    i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * s;
                                e.isLocked = e.size > i
                            } else e.isLocked = 1 === e.snapGrid.length;
                            !0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
                        }
                    },
                    classes: O,
                    images: {
                        loadImage: function(e, t, i, a, r, l) {
                            const o = (0, s.Jj)();
                            let p;

                            function d() {
                                l && l()
                            }
                            n(e).parent("picture")[0] || e.complete && r ? d() : t ? (p = new o.Image, p.onload = d, p.onerror = d, a && (p.sizes = a), i && (p.srcset = i), t && (p.src = t)) : d()
                        },
                        preloadImages: function() {
                            const e = this;

                            function t() {
                                "undefined" !== typeof e && null !== e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady")))
                            }
                            e.imagesToLoad = e.$el.find("img");
                            for (let i = 0; i < e.imagesToLoad.length; i += 1) {
                                const s = e.imagesToLoad[i];
                                e.loadImage(s, s.currentSrc || s.getAttribute("src"), s.srcset || s.getAttribute("srcset"), s.sizes || s.getAttribute("sizes"), !0, t)
                            }
                        }
                    }
                },
                G = {};
            class D {
                constructor(...e) {
                    let t, i;
                    if (1 === e.length && e[0].constructor && "Object" === Object.prototype.toString.call(e[0]).slice(8, -1) ? i = e[0] : [t, i] = e, i || (i = {}), i = d({}, i), t && !i.el && (i.el = t), i.el && n(i.el).length > 1) {
                        const e = [];
                        return n(i.el).each((t => {
                            const s = d({}, i, {
                                el: t
                            });
                            e.push(new D(s))
                        })), e
                    }
                    const a = this;
                    a.__swiper__ = !0, a.support = w(), a.device = function(e = {}) {
                        return g || (g = function({
                            userAgent: e
                        } = {}) {
                            const t = w(),
                                i = (0, s.Jj)(),
                                a = i.navigator.platform,
                                r = e || i.navigator.userAgent,
                                n = {
                                    ios: !1,
                                    android: !1
                                },
                                l = i.screen.width,
                                o = i.screen.height,
                                p = r.match(/(Android);?[\s\/]+([\d.]+)?/);
                            let d = r.match(/(iPad).*OS\s([\d_]+)/);
                            const c = r.match(/(iPod)(.*OS\s([\d_]+))?/),
                                u = !d && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                                f = "Win32" === a;
                            let g = "MacIntel" === a;
                            return !d && g && t.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${l}x${o}`) >= 0 && (d = r.match(/(Version)\/([\d.]+)/), d || (d = [0, 1, "13_0_0"]), g = !1), p && !f && (n.os = "android", n.android = !0), (d || u || c) && (n.os = "ios", n.ios = !0), n
                        }(e)), g
                    }({
                        userAgent: i.userAgent
                    }), a.browser = (h || (h = function() {
                        const e = (0, s.Jj)();
                        return {
                            isSafari: function() {
                                const t = e.navigator.userAgent.toLowerCase();
                                return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
                            }(),
                            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
                        }
                    }()), h), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], i.modules && Array.isArray(i.modules) && a.modules.push(...i.modules);
                    const r = {};
                    a.modules.forEach((e => {
                        e({
                            swiper: a,
                            extendParams: B(i, r),
                            on: a.on.bind(a),
                            once: a.once.bind(a),
                            off: a.off.bind(a),
                            emit: a.emit.bind(a)
                        })
                    }));
                    const l = d({}, I, r);
                    return a.params = d({}, l, G, i), a.originalParams = d({}, a.params), a.passedParams = d({}, i), a.params && a.params.on && Object.keys(a.params.on).forEach((e => {
                        a.on(e, a.params.on[e])
                    })), a.params && a.params.onAny && a.onAny(a.params.onAny), a.$ = n, Object.assign(a, {
                        enabled: a.params.enabled,
                        el: t,
                        classNames: [],
                        slides: n(),
                        slidesGrid: [],
                        snapGrid: [],
                        slidesSizesGrid: [],
                        isHorizontal: () => "horizontal" === a.params.direction,
                        isVertical: () => "vertical" === a.params.direction,
                        activeIndex: 0,
                        realIndex: 0,
                        isBeginning: !0,
                        isEnd: !1,
                        translate: 0,
                        previousTranslate: 0,
                        progress: 0,
                        velocity: 0,
                        animating: !1,
                        allowSlideNext: a.params.allowSlideNext,
                        allowSlidePrev: a.params.allowSlidePrev,
                        touchEvents: function() {
                            const e = ["touchstart", "touchmove", "touchend", "touchcancel"],
                                t = ["pointerdown", "pointermove", "pointerup"];
                            return a.touchEventsTouch = {
                                start: e[0],
                                move: e[1],
                                end: e[2],
                                cancel: e[3]
                            }, a.touchEventsDesktop = {
                                start: t[0],
                                move: t[1],
                                end: t[2]
                            }, a.support.touch || !a.params.simulateTouch ? a.touchEventsTouch : a.touchEventsDesktop
                        }(),
                        touchEventsData: {
                            isTouched: void 0,
                            isMoved: void 0,
                            allowTouchCallbacks: void 0,
                            touchStartTime: void 0,
                            isScrolling: void 0,
                            currentTranslate: void 0,
                            startTranslate: void 0,
                            allowThresholdMove: void 0,
                            focusableElements: a.params.focusableElements,
                            lastClickTime: o(),
                            clickTimeout: void 0,
                            velocities: [],
                            allowMomentumBounce: void 0,
                            isTouchEvent: void 0,
                            startMoving: void 0
                        },
                        allowClick: !0,
                        allowTouchMove: a.params.allowTouchMove,
                        touches: {
                            startX: 0,
                            startY: 0,
                            currentX: 0,
                            currentY: 0,
                            diff: 0
                        },
                        imagesToLoad: [],
                        imagesLoaded: 0
                    }), a.emit("_swiper"), a.params.init && a.init(), a
                }
                enable() {
                    const e = this;
                    e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
                }
                disable() {
                    const e = this;
                    e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
                }
                setProgress(e, t) {
                    const i = this;
                    e = Math.min(Math.max(e, 0), 1);
                    const s = i.minTranslate(),
                        a = (i.maxTranslate() - s) * e + s;
                    i.translateTo(a, "undefined" === typeof t ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses()
                }
                emitContainerClasses() {
                    const e = this;
                    if (!e.params._emitClasses || !e.el) return;
                    const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
                    e.emit("_containerClasses", t.join(" "))
                }
                getSlideClasses(e) {
                    const t = this;
                    return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
                }
                emitSlidesClasses() {
                    const e = this;
                    if (!e.params._emitClasses || !e.el) return;
                    const t = [];
                    e.slides.each((i => {
                        const s = e.getSlideClasses(i);
                        t.push({
                            slideEl: i,
                            classNames: s
                        }), e.emit("_slideClass", i, s)
                    })), e.emit("_slideClasses", t)
                }
                slidesPerViewDynamic(e = "current", t = !1) {
                    const {
                        params: i,
                        slides: s,
                        slidesGrid: a,
                        slidesSizesGrid: r,
                        size: n,
                        activeIndex: l
                    } = this;
                    let o = 1;
                    if (i.centeredSlides) {
                        let e, t = s[l].swiperSlideSize;
                        for (let i = l + 1; i < s.length; i += 1) s[i] && !e && (t += s[i].swiperSlideSize, o += 1, t > n && (e = !0));
                        for (let i = l - 1; i >= 0; i -= 1) s[i] && !e && (t += s[i].swiperSlideSize, o += 1, t > n && (e = !0))
                    } else if ("current" === e)
                        for (let e = l + 1; e < s.length; e += 1)(t ? a[e] + r[e] - a[l] < n : a[e] - a[l] < n) && (o += 1);
                    else
                        for (let e = l - 1; e >= 0; e -= 1) a[l] - a[e] < n && (o += 1);
                    return o
                }
                update() {
                    const e = this;
                    if (!e || e.destroyed) return;
                    const {
                        snapGrid: t,
                        params: i
                    } = e;

                    function s() {
                        const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                            i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                        e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses()
                    }
                    let a;
                    i.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (s(), e.params.autoHeight && e.updateAutoHeight()) : (a = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), a || s()), i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
                }
                changeDirection(e, t = !0) {
                    const i = this,
                        s = i.params.direction;
                    return e || (e = "horizontal" === s ? "vertical" : "horizontal"), e === s || "horizontal" !== e && "vertical" !== e || (i.$el.removeClass(`${i.params.containerModifierClass}${s}`).addClass(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.each((t => {
                        "vertical" === e ? t.style.width = "" : t.style.height = ""
                    })), i.emit("changeDirection"), t && i.update()), i
                }
                changeLanguageDirection(e) {
                    const t = this;
                    t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update())
                }
                mount(e) {
                    const t = this;
                    if (t.mounted) return !0;
                    const i = n(e || t.params.el);
                    if (!(e = i[0])) return !1;
                    e.swiper = t;
                    const a = () => `.${(t.params.wrapperClass||"").trim().split(" ").join(".")}`;
                    let r = (() => {
                        if (e && e.shadowRoot && e.shadowRoot.querySelector) {
                            const t = n(e.shadowRoot.querySelector(a()));
                            return t.children = e => i.children(e), t
                        }
                        return i.children ? i.children(a()) : n(i).children(a())
                    })();
                    if (0 === r.length && t.params.createElements) {
                        const e = (0, s.Me)().createElement("div");
                        r = n(e), e.className = t.params.wrapperClass, i.append(e), i.children(`.${t.params.slideClass}`).each((e => {
                            r.append(e)
                        }))
                    }
                    return Object.assign(t, {
                        $el: i,
                        el: e,
                        $wrapperEl: r,
                        wrapperEl: r[0],
                        mounted: !0,
                        rtl: "rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction"),
                        rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction")),
                        wrongRTL: "-webkit-box" === r.css("display")
                    }), !0
                }
                init(e) {
                    const t = this;
                    return t.initialized || !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t
                }
                destroy(e = !0, t = !0) {
                    const i = this,
                        {
                            params: s,
                            $el: a,
                            $wrapperEl: r,
                            slides: n
                        } = i;
                    return "undefined" === typeof i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), t && (i.removeClasses(), a.removeAttr("style"), r.removeAttr("style"), n && n.length && n.removeClass([s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((e => {
                        i.off(e)
                    })), !1 !== e && (i.$el[0].swiper = null, function(e) {
                        const t = e;
                        Object.keys(t).forEach((e => {
                            try {
                                t[e] = null
                            } catch (e) {}
                            try {
                                delete t[e]
                            } catch (e) {}
                        }))
                    }(i)), i.destroyed = !0), null
                }
                static extendDefaults(e) {
                    d(G, e)
                }
                static get extendedDefaults() {
                    return G
                }
                static get defaults() {
                    return I
                }
                static installModule(e) {
                    D.prototype.__modules__ || (D.prototype.__modules__ = []);
                    const t = D.prototype.__modules__;
                    "function" === typeof e && t.indexOf(e) < 0 && t.push(e)
                }
                static use(e) {
                    return Array.isArray(e) ? (e.forEach((e => D.installModule(e))), D) : (D.installModule(e), D)
                }
            }
            Object.keys(L).forEach((e => {
                Object.keys(L[e]).forEach((t => {
                    D.prototype[t] = L[e][t]
                }))
            })), D.use([function({
                swiper: e,
                on: t,
                emit: i
            }) {
                const a = (0, s.Jj)();
                let r = null,
                    n = null;
                const l = () => {
                        e && !e.destroyed && e.initialized && (i("beforeResize"), i("resize"))
                    },
                    o = () => {
                        e && !e.destroyed && e.initialized && i("orientationchange")
                    };
                t("init", (() => {
                    e.params.resizeObserver && "undefined" !== typeof a.ResizeObserver ? e && !e.destroyed && e.initialized && (r = new ResizeObserver((t => {
                        n = a.requestAnimationFrame((() => {
                            const {
                                width: i,
                                height: s
                            } = e;
                            let a = i,
                                r = s;
                            t.forEach((({
                                contentBoxSize: t,
                                contentRect: i,
                                target: s
                            }) => {
                                s && s !== e.el || (a = i ? i.width : (t[0] || t).inlineSize, r = i ? i.height : (t[0] || t).blockSize)
                            })), a === i && r === s || l()
                        }))
                    })), r.observe(e.el)) : (a.addEventListener("resize", l), a.addEventListener("orientationchange", o))
                })), t("destroy", (() => {
                    n && a.cancelAnimationFrame(n), r && r.unobserve && e.el && (r.unobserve(e.el), r = null), a.removeEventListener("resize", l), a.removeEventListener("orientationchange", o)
                }))
            }, function({
                swiper: e,
                extendParams: t,
                on: i,
                emit: a
            }) {
                const r = [],
                    n = (0, s.Jj)(),
                    l = (e, t = {}) => {
                        const i = new(n.MutationObserver || n.WebkitMutationObserver)((e => {
                            if (1 === e.length) return void a("observerUpdate", e[0]);
                            const t = function() {
                                a("observerUpdate", e[0])
                            };
                            n.requestAnimationFrame ? n.requestAnimationFrame(t) : n.setTimeout(t, 0)
                        }));
                        i.observe(e, {
                            attributes: "undefined" === typeof t.attributes || t.attributes,
                            childList: "undefined" === typeof t.childList || t.childList,
                            characterData: "undefined" === typeof t.characterData || t.characterData
                        }), r.push(i)
                    };
                t({
                    observer: !1,
                    observeParents: !1,
                    observeSlideChildren: !1
                }), i("init", (() => {
                    if (e.params.observer) {
                        if (e.params.observeParents) {
                            const t = e.$el.parents();
                            for (let e = 0; e < t.length; e += 1) l(t[e])
                        }
                        l(e.$el[0], {
                            childList: e.params.observeSlideChildren
                        }), l(e.$wrapperEl[0], {
                            attributes: !1
                        })
                    }
                })), i("destroy", (() => {
                    r.forEach((e => {
                        e.disconnect()
                    })), r.splice(0, r.length)
                }))
            }]);
            const _ = D;

            function j(e, t, i, a) {
                const r = (0, s.Me)();
                return e.params.createElements && Object.keys(a).forEach((s => {
                    if (!i[s] && !0 === i.auto) {
                        let n = e.$el.children(`.${a[s]}`)[0];
                        n || (n = r.createElement("div"), n.className = a[s], e.$el.append(n)), i[s] = n, t[s] = n
                    }
                })), i
            }

            function N({
                swiper: e,
                extendParams: t,
                on: i,
                emit: s
            }) {
                function a(t) {
                    let i;
                    return t && (i = n(t), e.params.uniqueNavElements && "string" === typeof t && i.length > 1 && 1 === e.$el.find(t).length && (i = e.$el.find(t))), i
                }

                function r(t, i) {
                    const s = e.params.navigation;
                    t && t.length > 0 && (t[i ? "addClass" : "removeClass"](s.disabledClass), t[0] && "BUTTON" === t[0].tagName && (t[0].disabled = i), e.params.watchOverflow && e.enabled && t[e.isLocked ? "addClass" : "removeClass"](s.lockClass))
                }

                function l() {
                    if (e.params.loop) return;
                    const {
                        $nextEl: t,
                        $prevEl: i
                    } = e.navigation;
                    r(i, e.isBeginning && !e.params.rewind), r(t, e.isEnd && !e.params.rewind)
                }

                function o(t) {
                    t.preventDefault(), (!e.isBeginning || e.params.loop || e.params.rewind) && (e.slidePrev(), s("navigationPrev"))
                }

                function p(t) {
                    t.preventDefault(), (!e.isEnd || e.params.loop || e.params.rewind) && (e.slideNext(), s("navigationNext"))
                }

                function d() {
                    const t = e.params.navigation;
                    if (e.params.navigation = j(e, e.originalParams.navigation, e.params.navigation, {
                            nextEl: "swiper-button-next",
                            prevEl: "swiper-button-prev"
                        }), !t.nextEl && !t.prevEl) return;
                    const i = a(t.nextEl),
                        s = a(t.prevEl);
                    i && i.length > 0 && i.on("click", p), s && s.length > 0 && s.on("click", o), Object.assign(e.navigation, {
                        $nextEl: i,
                        nextEl: i && i[0],
                        $prevEl: s,
                        prevEl: s && s[0]
                    }), e.enabled || (i && i.addClass(t.lockClass), s && s.addClass(t.lockClass))
                }

                function c() {
                    const {
                        $nextEl: t,
                        $prevEl: i
                    } = e.navigation;
                    t && t.length && (t.off("click", p), t.removeClass(e.params.navigation.disabledClass)), i && i.length && (i.off("click", o), i.removeClass(e.params.navigation.disabledClass))
                }
                t({
                    navigation: {
                        nextEl: null,
                        prevEl: null,
                        hideOnClick: !1,
                        disabledClass: "swiper-button-disabled",
                        hiddenClass: "swiper-button-hidden",
                        lockClass: "swiper-button-lock",
                        navigationDisabledClass: "swiper-navigation-disabled"
                    }
                }), e.navigation = {
                    nextEl: null,
                    $nextEl: null,
                    prevEl: null,
                    $prevEl: null
                }, i("init", (() => {
                    !1 === e.params.navigation.enabled ? u() : (d(), l())
                })), i("toEdge fromEdge lock unlock", (() => {
                    l()
                })), i("destroy", (() => {
                    c()
                })), i("enable disable", (() => {
                    const {
                        $nextEl: t,
                        $prevEl: i
                    } = e.navigation;
                    t && t[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass), i && i[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass)
                })), i("click", ((t, i) => {
                    const {
                        $nextEl: a,
                        $prevEl: r
                    } = e.navigation, l = i.target;
                    if (e.params.navigation.hideOnClick && !n(l).is(r) && !n(l).is(a)) {
                        if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === l || e.pagination.el.contains(l))) return;
                        let t;
                        a ? t = a.hasClass(e.params.navigation.hiddenClass) : r && (t = r.hasClass(e.params.navigation.hiddenClass)), s(!0 === t ? "navigationShow" : "navigationHide"), a && a.toggleClass(e.params.navigation.hiddenClass), r && r.toggleClass(e.params.navigation.hiddenClass)
                    }
                }));
                const u = () => {
                    e.$el.addClass(e.params.navigation.navigationDisabledClass), c()
                };
                Object.assign(e.navigation, {
                    enable: () => {
                        e.$el.removeClass(e.params.navigation.navigationDisabledClass), d(), l()
                    },
                    disable: u,
                    update: l,
                    init: d,
                    destroy: c
                })
            }

            function Y(e = "") {
                return `.${e.trim().replace(/([\.:!\/])/g,"\\$1").replace(/ /g,".")}`
            }

            function F({
                swiper: e,
                extendParams: t,
                on: i,
                emit: s
            }) {
                const a = "swiper-pagination";
                let r;
                t({
                    pagination: {
                        el: null,
                        bulletElement: "span",
                        clickable: !1,
                        hideOnClick: !1,
                        renderBullet: null,
                        renderProgressbar: null,
                        renderFraction: null,
                        renderCustom: null,
                        progressbarOpposite: !1,
                        type: "bullets",
                        dynamicBullets: !1,
                        dynamicMainBullets: 1,
                        formatFractionCurrent: e => e,
                        formatFractionTotal: e => e,
                        bulletClass: `${a}-bullet`,
                        bulletActiveClass: `${a}-bullet-active`,
                        modifierClass: `${a}-`,
                        currentClass: `${a}-current`,
                        totalClass: `${a}-total`,
                        hiddenClass: `${a}-hidden`,
                        progressbarFillClass: `${a}-progressbar-fill`,
                        progressbarOppositeClass: `${a}-progressbar-opposite`,
                        clickableClass: `${a}-clickable`,
                        lockClass: `${a}-lock`,
                        horizontalClass: `${a}-horizontal`,
                        verticalClass: `${a}-vertical`,
                        paginationDisabledClass: `${a}-disabled`
                    }
                }), e.pagination = {
                    el: null,
                    $el: null,
                    bullets: []
                };
                let l = 0;

                function o() {
                    return !e.params.pagination.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length
                }

                function p(t, i) {
                    const {
                        bulletActiveClass: s
                    } = e.params.pagination;
                    t[i]().addClass(`${s}-${i}`)[i]().addClass(`${s}-${i}-${i}`)
                }

                function d() {
                    const t = e.rtl,
                        i = e.params.pagination;
                    if (o()) return;
                    const a = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
                        d = e.pagination.$el;
                    let c;
                    const u = e.params.loop ? Math.ceil((a - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length;
                    if (e.params.loop ? (c = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), c > a - 1 - 2 * e.loopedSlides && (c -= a - 2 * e.loopedSlides), c > u - 1 && (c -= u), c < 0 && "bullets" !== e.params.paginationType && (c = u + c)) : c = "undefined" !== typeof e.snapIndex ? e.snapIndex : e.activeIndex || 0, "bullets" === i.type && e.pagination.bullets && e.pagination.bullets.length > 0) {
                        const s = e.pagination.bullets;
                        let a, o, u;
                        if (i.dynamicBullets && (r = s.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), d.css(e.isHorizontal() ? "width" : "height", r * (i.dynamicMainBullets + 4) + "px"), i.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (l += c - (e.previousIndex - e.loopedSlides || 0), l > i.dynamicMainBullets - 1 ? l = i.dynamicMainBullets - 1 : l < 0 && (l = 0)), a = Math.max(c - l, 0), o = a + (Math.min(s.length, i.dynamicMainBullets) - 1), u = (o + a) / 2), s.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${i.bulletActiveClass}${e}`)).join(" ")), d.length > 1) s.each((e => {
                            const t = n(e),
                                s = t.index();
                            s === c && t.addClass(i.bulletActiveClass), i.dynamicBullets && (s >= a && s <= o && t.addClass(`${i.bulletActiveClass}-main`), s === a && p(t, "prev"), s === o && p(t, "next"))
                        }));
                        else {
                            const t = s.eq(c),
                                r = t.index();
                            if (t.addClass(i.bulletActiveClass), i.dynamicBullets) {
                                const t = s.eq(a),
                                    n = s.eq(o);
                                for (let e = a; e <= o; e += 1) s.eq(e).addClass(`${i.bulletActiveClass}-main`);
                                if (e.params.loop)
                                    if (r >= s.length) {
                                        for (let e = i.dynamicMainBullets; e >= 0; e -= 1) s.eq(s.length - e).addClass(`${i.bulletActiveClass}-main`);
                                        s.eq(s.length - i.dynamicMainBullets - 1).addClass(`${i.bulletActiveClass}-prev`)
                                    } else p(t, "prev"), p(n, "next");
                                else p(t, "prev"), p(n, "next")
                            }
                        }
                        if (i.dynamicBullets) {
                            const a = Math.min(s.length, i.dynamicMainBullets + 4),
                                n = (r * a - r) / 2 - u * r,
                                l = t ? "right" : "left";
                            s.css(e.isHorizontal() ? l : "top", `${n}px`)
                        }
                    }
                    if ("fraction" === i.type && (d.find(Y(i.currentClass)).text(i.formatFractionCurrent(c + 1)), d.find(Y(i.totalClass)).text(i.formatFractionTotal(u))), "progressbar" === i.type) {
                        let t;
                        t = i.progressbarOpposite ? e.isHorizontal() ? "vertical" : "horizontal" : e.isHorizontal() ? "horizontal" : "vertical";
                        const s = (c + 1) / u;
                        let a = 1,
                            r = 1;
                        "horizontal" === t ? a = s : r = s, d.find(Y(i.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${a}) scaleY(${r})`).transition(e.params.speed)
                    }
                    "custom" === i.type && i.renderCustom ? (d.html(i.renderCustom(e, c + 1, u)), s("paginationRender", d[0])) : s("paginationUpdate", d[0]), e.params.watchOverflow && e.enabled && d[e.isLocked ? "addClass" : "removeClass"](i.lockClass)
                }

                function c() {
                    const t = e.params.pagination;
                    if (o()) return;
                    const i = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
                        a = e.pagination.$el;
                    let r = "";
                    if ("bullets" === t.type) {
                        let s = e.params.loop ? Math.ceil((i - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length;
                        e.params.freeMode && e.params.freeMode.enabled && !e.params.loop && s > i && (s = i);
                        for (let i = 0; i < s; i += 1) t.renderBullet ? r += t.renderBullet.call(e, i, t.bulletClass) : r += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`;
                        a.html(r), e.pagination.bullets = a.find(Y(t.bulletClass))
                    }
                    "fraction" === t.type && (r = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span> / <span class="${t.totalClass}"></span>`, a.html(r)), "progressbar" === t.type && (r = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, a.html(r)), "custom" !== t.type && s("paginationRender", e.pagination.$el[0])
                }

                function u() {
                    e.params.pagination = j(e, e.originalParams.pagination, e.params.pagination, {
                        el: "swiper-pagination"
                    });
                    const t = e.params.pagination;
                    if (!t.el) return;
                    let i = n(t.el);
                    0 !== i.length && (e.params.uniqueNavElements && "string" === typeof t.el && i.length > 1 && (i = e.$el.find(t.el), i.length > 1 && (i = i.filter((t => n(t).parents(".swiper")[0] === e.el)))), "bullets" === t.type && t.clickable && i.addClass(t.clickableClass), i.addClass(t.modifierClass + t.type), i.addClass(e.isHorizontal() ? t.horizontalClass : t.verticalClass), "bullets" === t.type && t.dynamicBullets && (i.addClass(`${t.modifierClass}${t.type}-dynamic`), l = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), "progressbar" === t.type && t.progressbarOpposite && i.addClass(t.progressbarOppositeClass), t.clickable && i.on("click", Y(t.bulletClass), (function(t) {
                        t.preventDefault();
                        let i = n(this).index() * e.params.slidesPerGroup;
                        e.params.loop && (i += e.loopedSlides), e.slideTo(i)
                    })), Object.assign(e.pagination, {
                        $el: i,
                        el: i[0]
                    }), e.enabled || i.addClass(t.lockClass))
                }

                function f() {
                    const t = e.params.pagination;
                    if (o()) return;
                    const i = e.pagination.$el;
                    i.removeClass(t.hiddenClass), i.removeClass(t.modifierClass + t.type), i.removeClass(e.isHorizontal() ? t.horizontalClass : t.verticalClass), e.pagination.bullets && e.pagination.bullets.removeClass && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && i.off("click", Y(t.bulletClass))
                }
                i("init", (() => {
                    !1 === e.params.pagination.enabled ? g() : (u(), c(), d())
                })), i("activeIndexChange", (() => {
                    (e.params.loop || "undefined" === typeof e.snapIndex) && d()
                })), i("snapIndexChange", (() => {
                    e.params.loop || d()
                })), i("slidesLengthChange", (() => {
                    e.params.loop && (c(), d())
                })), i("snapGridLengthChange", (() => {
                    e.params.loop || (c(), d())
                })), i("destroy", (() => {
                    f()
                })), i("enable disable", (() => {
                    const {
                        $el: t
                    } = e.pagination;
                    t && t[e.enabled ? "removeClass" : "addClass"](e.params.pagination.lockClass)
                })), i("lock unlock", (() => {
                    d()
                })), i("click", ((t, i) => {
                    const a = i.target,
                        {
                            $el: r
                        } = e.pagination;
                    if (e.params.pagination.el && e.params.pagination.hideOnClick && r && r.length > 0 && !n(a).hasClass(e.params.pagination.bulletClass)) {
                        if (e.navigation && (e.navigation.nextEl && a === e.navigation.nextEl || e.navigation.prevEl && a === e.navigation.prevEl)) return;
                        const t = r.hasClass(e.params.pagination.hiddenClass);
                        s(!0 === t ? "paginationShow" : "paginationHide"), r.toggleClass(e.params.pagination.hiddenClass)
                    }
                }));
                const g = () => {
                    e.$el.addClass(e.params.pagination.paginationDisabledClass), e.pagination.$el && e.pagination.$el.addClass(e.params.pagination.paginationDisabledClass), f()
                };
                Object.assign(e.pagination, {
                    enable: () => {
                        e.$el.removeClass(e.params.pagination.paginationDisabledClass), e.pagination.$el && e.pagination.$el.removeClass(e.params.pagination.paginationDisabledClass), u(), c(), d()
                    },
                    disable: g,
                    render: c,
                    update: d,
                    init: u,
                    destroy: f
                })
            }

            function R({
                swiper: e,
                extendParams: t,
                on: i,
                emit: a
            }) {
                let r;

                function n() {
                    if (!e.size) return e.autoplay.running = !1, void(e.autoplay.paused = !1);
                    const t = e.slides.eq(e.activeIndex);
                    let i = e.params.autoplay.delay;
                    t.attr("data-swiper-autoplay") && (i = t.attr("data-swiper-autoplay") || e.params.autoplay.delay), clearTimeout(r), r = l((() => {
                        let t;
                        e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), t = e.slidePrev(e.params.speed, !0, !0), a("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? p() : (t = e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), a("autoplay")) : (t = e.slidePrev(e.params.speed, !0, !0), a("autoplay")) : e.params.loop ? (e.loopFix(), t = e.slideNext(e.params.speed, !0, !0), a("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? p() : (t = e.slideTo(0, e.params.speed, !0, !0), a("autoplay")) : (t = e.slideNext(e.params.speed, !0, !0), a("autoplay")), (e.params.cssMode && e.autoplay.running || !1 === t) && n()
                    }), i)
                }

                function o() {
                    return "undefined" === typeof r && !e.autoplay.running && (e.autoplay.running = !0, a("autoplayStart"), n(), !0)
                }

                function p() {
                    return !!e.autoplay.running && "undefined" !== typeof r && (r && (clearTimeout(r), r = void 0), e.autoplay.running = !1, a("autoplayStop"), !0)
                }

                function d(t) {
                    e.autoplay.running && (e.autoplay.paused || (r && clearTimeout(r), e.autoplay.paused = !0, 0 !== t && e.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((t => {
                        e.$wrapperEl[0].addEventListener(t, u)
                    })) : (e.autoplay.paused = !1, n())))
                }

                function c() {
                    const t = (0, s.Me)();
                    "hidden" === t.visibilityState && e.autoplay.running && d(), "visible" === t.visibilityState && e.autoplay.paused && (n(), e.autoplay.paused = !1)
                }

                function u(t) {
                    e && !e.destroyed && e.$wrapperEl && t.target === e.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((t => {
                        e.$wrapperEl[0].removeEventListener(t, u)
                    })), e.autoplay.paused = !1, e.autoplay.running ? n() : p())
                }

                function f() {
                    e.params.autoplay.disableOnInteraction ? p() : (a("autoplayPause"), d()), ["transitionend", "webkitTransitionEnd"].forEach((t => {
                        e.$wrapperEl[0].removeEventListener(t, u)
                    }))
                }

                function g() {
                    e.params.autoplay.disableOnInteraction || (e.autoplay.paused = !1, a("autoplayResume"), n())
                }
                e.autoplay = {
                    running: !1,
                    paused: !1
                }, t({
                    autoplay: {
                        enabled: !1,
                        delay: 3e3,
                        waitForTransition: !0,
                        disableOnInteraction: !0,
                        stopOnLastSlide: !1,
                        reverseDirection: !1,
                        pauseOnMouseEnter: !1
                    }
                }), i("init", (() => {
                    e.params.autoplay.enabled && (o(), (0, s.Me)().addEventListener("visibilitychange", c), e.params.autoplay.pauseOnMouseEnter && (e.$el.on("mouseenter", f), e.$el.on("mouseleave", g)))
                })), i("beforeTransitionStart", ((t, i, s) => {
                    e.autoplay.running && (s || !e.params.autoplay.disableOnInteraction ? e.autoplay.pause(i) : p())
                })), i("sliderFirstMove", (() => {
                    e.autoplay.running && (e.params.autoplay.disableOnInteraction ? p() : d())
                })), i("touchEnd", (() => {
                    e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && n()
                })), i("destroy", (() => {
                    e.$el.off("mouseenter", f), e.$el.off("mouseleave", g), e.autoplay.running && p(), (0, s.Me)().removeEventListener("visibilitychange", c)
                })), Object.assign(e.autoplay, {
                    pause: d,
                    run: n,
                    start: o,
                    stop: p
                })
            }

            function H({
                swiper: e,
                extendParams: t,
                on: i
            }) {
                t({
                    thumbs: {
                        swiper: null,
                        multipleActiveThumbs: !0,
                        autoScrollOffset: 0,
                        slideThumbActiveClass: "swiper-slide-thumb-active",
                        thumbsContainerClass: "swiper-thumbs"
                    }
                });
                let s = !1,
                    a = !1;

                function r() {
                    const t = e.thumbs.swiper;
                    if (!t || t.destroyed) return;
                    const i = t.clickedIndex,
                        s = t.clickedSlide;
                    if (s && n(s).hasClass(e.params.thumbs.slideThumbActiveClass)) return;
                    if ("undefined" === typeof i || null === i) return;
                    let a;
                    if (a = t.params.loop ? parseInt(n(t.clickedSlide).attr("data-swiper-slide-index"), 10) : i, e.params.loop) {
                        let t = e.activeIndex;
                        e.slides.eq(t).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, t = e.activeIndex);
                        const i = e.slides.eq(t).prevAll(`[data-swiper-slide-index="${a}"]`).eq(0).index(),
                            s = e.slides.eq(t).nextAll(`[data-swiper-slide-index="${a}"]`).eq(0).index();
                        a = "undefined" === typeof i ? s : "undefined" === typeof s ? i : s - t < t - i ? s : i
                    }
                    e.slideTo(a)
                }

                function l() {
                    const {
                        thumbs: t
                    } = e.params;
                    if (s) return !1;
                    s = !0;
                    const i = e.constructor;
                    if (t.swiper instanceof i) e.thumbs.swiper = t.swiper, Object.assign(e.thumbs.swiper.originalParams, {
                        watchSlidesProgress: !0,
                        slideToClickedSlide: !1
                    }), Object.assign(e.thumbs.swiper.params, {
                        watchSlidesProgress: !0,
                        slideToClickedSlide: !1
                    });
                    else if (p(t.swiper)) {
                        const s = Object.assign({}, t.swiper);
                        Object.assign(s, {
                            watchSlidesProgress: !0,
                            slideToClickedSlide: !1
                        }), e.thumbs.swiper = new i(s), a = !0
                    }
                    return e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", r), !0
                }

                function o(t) {
                    const i = e.thumbs.swiper;
                    if (!i || i.destroyed) return;
                    const s = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView;
                    let a = 1;
                    const r = e.params.thumbs.slideThumbActiveClass;
                    if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (a = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (a = 1), a = Math.floor(a), i.slides.removeClass(r), i.params.loop || i.params.virtual && i.params.virtual.enabled)
                        for (let t = 0; t < a; t += 1) i.$wrapperEl.children(`[data-swiper-slide-index="${e.realIndex+t}"]`).addClass(r);
                    else
                        for (let t = 0; t < a; t += 1) i.slides.eq(e.realIndex + t).addClass(r);
                    const n = e.params.thumbs.autoScrollOffset,
                        l = n && !i.params.loop;
                    if (e.realIndex !== i.realIndex || l) {
                        let a, r, o = i.activeIndex;
                        if (i.params.loop) {
                            i.slides.eq(o).hasClass(i.params.slideDuplicateClass) && (i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft, o = i.activeIndex);
                            const t = i.slides.eq(o).prevAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index(),
                                s = i.slides.eq(o).nextAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index();
                            a = "undefined" === typeof t ? s : "undefined" === typeof s ? t : s - o === o - t ? i.params.slidesPerGroup > 1 ? s : o : s - o < o - t ? s : t, r = e.activeIndex > e.previousIndex ? "next" : "prev"
                        } else a = e.realIndex, r = a > e.previousIndex ? "next" : "prev";
                        l && (a += "next" === r ? n : -1 * n), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(a) < 0 && (i.params.centeredSlides ? a = a > o ? a - Math.floor(s / 2) + 1 : a + Math.floor(s / 2) - 1 : a > o && i.params.slidesPerGroup, i.slideTo(a, t ? 0 : void 0))
                    }
                }
                e.thumbs = {
                    swiper: null
                }, i("beforeInit", (() => {
                    const {
                        thumbs: t
                    } = e.params;
                    t && t.swiper && (l(), o(!0))
                })), i("slideChange update resize observerUpdate", (() => {
                    o()
                })), i("setTransition", ((t, i) => {
                    const s = e.thumbs.swiper;
                    s && !s.destroyed && s.setTransition(i)
                })), i("beforeDestroy", (() => {
                    const t = e.thumbs.swiper;
                    t && !t.destroyed && a && t.destroy()
                })), Object.assign(e.thumbs, {
                    init: l,
                    update: o
                })
            }
        }
    }
]);